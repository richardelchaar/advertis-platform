----- FILE: docker-compose.yml -----
# Defines the multi-container application for local development.
# To run: docker-compose up --build
version: '3.8'

services:
  # PostgreSQL database for the Host Application
  host_db:
    image: postgres:15-alpine
    container_name: host_db
    environment:
      - POSTGRES_USER=questweaver
      - POSTGRES_PASSWORD=secret
      - POSTGRES_DB=questweaver_db
    ports:
      - "5433:5432" # Exposes the DB port to the host machine for inspection
    volumes:
      - host_db_data:/var/lib/postgresql/data # Persists DB data across restarts
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U questweaver -d questweaver_db"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # Redis cache for the Advertis Service's Frequency Gate
  redis:
    image: redis:7-alpine
    container_name: redis
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5
    restart: unless-stopped

  # ChromaDB for the Advertis Service's semantic ad search
  chroma_db:
    image: chromadb/chroma
    container_name: chroma_db
    ports:
      - "8001:8000" # Maps Chroma's internal port 8000 to 8001 on host

    restart: unless-stopped

  # The Host Application Backend (QuestWeaver)
  host_app:
    build:
      context: ./host_app
      dockerfile: Dockerfile
    container_name: host_app
    ports:
      - "8080:8000" # Maps container port 8000 to host port 8080
    volumes:
      - ./host_app/app:/code/app # Mounts local code for live reloading
    env_file: ./.env
    depends_on:
      host_db:
        condition: service_healthy # Ensures DB is ready before starting
      advertis_service:
        condition: service_started # Waits for advertis_service to start
    restart: unless-stopped

  # The Advertis Inference Service
  advertis_service:
    build:
      context: ./advertis_service
      dockerfile: Dockerfile
    container_name: advertis_service
    ports:
      - "8081:8000" # Maps container port 8000 to host port 8081
    volumes:
      - ./advertis_service/app:/code/app
    env_file: ./.env
    depends_on:
      redis:
        condition: service_healthy # Ensures Redis is ready
      chroma_db:
        condition: service_started
    restart: unless-stopped

volumes:
  host_db_data: # Defines the named volume for data persistence
  chroma_db_data:

----- FILE: pytest.ini -----
[pytest]
minversion = 6.0
testpaths =
    advertis_service/evaluation
    host_app/evaluation
asyncio_mode = auto

----- FILE: README.md -----
# Advertis Platform

This repository contains the microservices architecture for the "Advertis" Protocol.

It includes:
- `host_app`: The "QuestWeaver" chatbot application that owns user data.
- `advertis_service`: The "Narrative-as-a-Service" inference API for monetization.

----- FILE: host_app/Dockerfile -----
# Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set environment variables to prevent Python from writing pyc files to disc
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set the working directory in the container
WORKDIR /code

# Copy the requirements file into the container
COPY ./requirements.txt /code/requirements.txt

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

# Copy the application code into the container
COPY ./app /code/app

# Command to run the Streamlit application
# --server.port 8000 makes it run on the port we defined in docker-compose
# --server.address 0.0.0.0 makes it accessible from outside the container
CMD ["python", "-m", "streamlit", "run", "app/app.py", "--server.port=8000", "--server.address=0.0.0.0"]

----- FILE: host_app/requirements-dev.txt -----
# Core application framework
streamlit

# Utilities
python-dotenv

# For making async API calls to advertis_service
httpx

# Database ORM and PostgreSQL driver
SQLAlchemy
psycopg2-binary

# For our fallback LLM
langchain-openai

# --- Testing Dependencies ---
pytest
pytest-asyncio
pytest-mock
# Note: SQLAlchemy is already listed above, no need to repeat 

----- FILE: host_app/requirements.txt -----
# Core application framework
streamlit

# Utilities
python-dotenv

# For making async API calls to advertis_service
httpx

# Database ORM and PostgreSQL driver
SQLAlchemy
psycopg2-binary

# For our fallback LLM
langchain-openai

----- FILE: host_app/app/__init__.py -----

----- FILE: host_app/app/app.py -----
import sys
sys.path.insert(0, '/code')

import streamlit as st
import uuid
import asyncio
from app.services import database, advertis_client, fallback_llm

# Module-level placeholders for dependencies used by get_final_response
db_session = None
selected_vertical = None


async def get_final_response(db_session, session_id: uuid.UUID, prompt: str) -> str:
    """
    Orchestrates getting the final response by calling the simplified SDK wrapper.
    """
    # Get the full history from the database
    history = database.get_chat_history(db_session, session_id)

    # The implementation is now just a single, declarative line!
    return await advertis_client.get_monetized_response(
        session_id=str(session_id),
        app_vertical=selected_vertical,
        history=history,
        fallback_func=fallback_llm.get_fallback_response
    )


def main():
    global db_session, selected_vertical
    # Initialize DB session and ensure dummy user exists at app start
    db_session = next(database.get_db())
    dummy_user = database.get_or_create_dummy_user(db_session)

    # --- Page Configuration ---
    st.set_page_config(page_title="Advertis Host App", page_icon="ðŸ ")

    # --- Sidebar for Session Control ---
    st.sidebar.title("Session Control")

    # Dropdown to select the vertical. For now, only "gaming" is available.
    # In the future, the agent_registry would provide these keys.
    available_verticals = ["gaming"]  # In a real app: agent_registry.agent_registry.keys()
    selected_vertical = st.sidebar.selectbox(
        "Select Application Vertical:",
        options=available_verticals
    )

    # Text area for the system prompt
    system_prompt = st.sidebar.text_area(
        "Enter System Prompt:",
        value="You are a sarcastic and world-weary Game Master running a noir detective story in a cyberpunk city.",
        height=150
    )

    # Button to start a new chat
    if st.sidebar.button("Start New Chat"):
        # Create a new session in the database
        new_session = database.create_chat_session(
            db_session=db_session,
            user_id=dummy_user.id,
            system_prompt=system_prompt,
            app_vertical=selected_vertical
        )
        # Store the new session ID and reset messages in Streamlit's state
        st.session_state.session_id = new_session.id
        st.session_state.messages = [{"role": "system", "content": system_prompt}]
        st.rerun()  # Rerun the script to reflect the new state

    # --- Main Chat Interface ---
    st.title("ðŸ¤– Advertis Protocol Demo")
    st.caption("This application simulates a customer integrating the Advertis monetization service.")

    # Initialize chat history in session state if it doesn't exist
    if "messages" not in st.session_state:
        st.session_state.messages = []

    # Display past messages from session state
    for message in st.session_state.messages:
        if message["role"] != "system":  # Don't display the system prompt
            with st.chat_message(message["role"]):
                st.markdown(message["content"])

    # Handle user input
    if prompt := st.chat_input("What do you do?"):
        if "session_id" not in st.session_state:
            st.error("Please start a new chat from the sidebar first!")
        else:
            session_id = st.session_state.session_id

            # Add user message to state and display it
            st.session_state.messages.append({"role": "user", "content": prompt})
            with st.chat_message("user"):
                st.markdown(prompt)

            # Save user message to DB
            database.save_message(db_session, session_id, "user", prompt)

            # --- THIS IS THE REFACTORED ORCHESTRATION LOGIC ---
            with st.chat_message("assistant"):
                with st.spinner("Thinking..."):
                    # Call the async orchestrator function just once
                    final_response_text = asyncio.run(get_final_response(db_session, session_id, prompt))
                    st.markdown(final_response_text)

            # Add AI response to state and save to DB
            st.session_state.messages.append({"role": "assistant", "content": final_response_text})
            database.save_message(db_session, session_id, "assistant", final_response_text)


if __name__ == "__main__":
    main()

----- FILE: host_app/app/config.py -----
# host_app/app/config.py
import os
from dotenv import load_dotenv

load_dotenv()

# URL for the host app's own database
DATABASE_URL = os.getenv("DATABASE_URL")

# URL to connect to our other microservice
ADVERTIS_API_URL = os.getenv("ADVERTIS_API_URL", "http://advertis_service:8000")

OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")

if not DATABASE_URL:
    raise ValueError("FATAL: DATABASE_URL environment variable is missing.")

----- FILE: host_app/app/services/__init__.py -----

----- FILE: host_app/app/services/advertis_client.py -----
# host_app/app/services/advertis_client.py
import httpx
from typing import List, Dict, Optional, Callable, Awaitable
from pydantic import BaseModel
from app import config

# --- Pydantic Models for Deserialization ---
class CheckResponse(BaseModel):
    proceed: bool
    reason: str

class AdResponse(BaseModel):
    status: str
    response_text: Optional[str] = None

# --- Low-Level API Functions ---
async def _check_opportunity(session_id: str, last_message: str) -> CheckResponse:
    """Makes the fast 'pre-flight' call to the advertis service."""
    url = f"{config.ADVERTIS_API_URL}/v1/check-opportunity"
    payload = {"session_id": session_id, "last_message": last_message}
    
    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(url, json=payload, timeout=5.0)
            response.raise_for_status()
            return CheckResponse.model_validate(response.json())
        except (httpx.HTTPStatusError, httpx.RequestError) as e:
            print(f"SDK LOG: Error in check_opportunity: {e}")
            return CheckResponse(proceed=False, reason="Advertis service error")

async def _get_response(session_id: str, app_vertical: str, history: List[Dict]) -> AdResponse:
    """Makes the main call to get a potentially monetized response."""
    url = f"{config.ADVERTIS_API_URL}/v1/get-response"
    payload = {
        "session_id": session_id,
        "app_vertical": app_vertical,
        "conversation_history": history
    }

    async with httpx.AsyncClient() as client:
        try:
            response = await client.post(url, json=payload, timeout=20.0)
            response.raise_for_status()
            return AdResponse.model_validate(response.json())
        except (httpx.HTTPStatusError, httpx.RequestError) as e:
            print(f"SDK LOG: Error in get_response: {e}")
            return AdResponse(status="skip", response_text=None)

# --- HIGH-LEVEL SDK WRAPPER FUNCTION (FOR CUSTOMERS) ---
async def get_monetized_response(
    session_id: str,
    app_vertical: str,
    history: List[Dict],
    fallback_func: Callable[[List[Dict]], Awaitable[str]]
) -> str:
    """
    The main SDK function. It orchestrates the hybrid model logic.
    """
    last_message = history[-1]["content"]
    opportunity = await _check_opportunity(session_id, last_message)

    if opportunity.proceed:
        ad_response = await _get_response(session_id, app_vertical, history)
        if ad_response.status == "inject":
            print("SDK LOG: Injecting response from Advertis.")
            return ad_response.response_text
        else:
            print("SDK LOG: Advertis skipped. Using fallback.")
            return await fallback_func(history)
    else:
        print(f"SDK LOG: Pre-flight check failed ({opportunity.reason}). Using fallback.")
        return await fallback_func(history)

----- FILE: host_app/app/services/database.py -----
# host_app/app/services/database.py
import uuid
from datetime import datetime
from typing import List, Dict

from sqlalchemy import (create_engine, Column, Integer, String, 
                        DateTime, ForeignKey, Text, CheckConstraint)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import sessionmaker, declarative_base, relationship

from app import config

# --- Database Setup ---
engine = create_engine(config.DATABASE_URL)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
Base = declarative_base()


# --- ORM Models (Defines our tables) ---
class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    sessions = relationship("ChatSession", back_populates="user")

class ChatSession(Base):
    __tablename__ = "chat_sessions"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(Integer, ForeignKey("users.id"))
    created_at = Column(DateTime, default=datetime.utcnow)
    system_prompt = Column(Text, nullable=True)
    app_vertical = Column(String, nullable=False)
    
    user = relationship("User", back_populates="sessions")
    messages = relationship("ChatMessage", back_populates="session", cascade="all, delete-orphan")

class ChatMessage(Base):
    __tablename__ = "chat_messages"
    id = Column(Integer, primary_key=True, index=True)
    session_id = Column(UUID(as_uuid=True), ForeignKey("chat_sessions.id"))
    role = Column(String, CheckConstraint("role IN ('user', 'assistant', 'system')"), nullable=False)
    content = Column(Text, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    
    session = relationship("ChatSession", back_populates="messages")


# --- Database Initialization ---
def init_db():
    """Creates all database tables if they don't exist."""
    print("DATABASE: Initializing database and creating tables...")
    Base.metadata.create_all(bind=engine)
    print("DATABASE: Tables created successfully.")


def get_or_create_dummy_user(db_session):
    """Finds the dummy user with ID 1, or creates it if it doesn't exist."""
    dummy_user = db_session.query(User).filter(User.id == 1).first()
    if not dummy_user:
        print("DATABASE: Dummy user not found. Creating...")
        dummy_user = User(id=1, username="dummy_user")
        db_session.add(dummy_user)
        db_session.commit()
        db_session.refresh(dummy_user)
        print("DATABASE: Dummy user created.")
    return dummy_user


# --- Helper Functions (What our app will use) ---
def get_db():
    """Dependency to get a DB session."""
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

def create_chat_session(db_session, user_id: int, system_prompt: str, app_vertical: str) -> ChatSession:
    """Creates a new chat session and its initial system message in the database."""
    # Step 1: Create the session object
    new_session = ChatSession(
        user_id=user_id,
        system_prompt=system_prompt,
        app_vertical=app_vertical
    )
    db_session.add(new_session)
    db_session.commit()
    db_session.refresh(new_session) # This populates the new_session.id from the DB

    # Step 2: Now that the session has an ID, create the system message
    system_message = ChatMessage(
        session_id=new_session.id, 
        role="system", 
        content=system_prompt
    )
    db_session.add(system_message)
    db_session.commit() # Commit the new message

    return new_session

def get_chat_history(db_session, session_id: uuid.UUID) -> List[Dict]:
    """Retrieves the conversation history for a given session."""
    messages = db_session.query(ChatMessage).filter(ChatMessage.session_id == session_id).order_by(ChatMessage.created_at).all()
    return [{"role": msg.role, "content": msg.content} for msg in messages]

def save_message(db_session, session_id: uuid.UUID, role: str, content: str):
    """Saves a new message to the conversation history."""
    new_message = ChatMessage(session_id=session_id, role=role, content=content)
    db_session.add(new_message)
    db_session.commit()



----- FILE: host_app/app/services/fallback_llm.py -----
# host_app/app/services/fallback_llm.py
from typing import List, Dict
from langchain_openai import ChatOpenAI
from app import config

async def get_fallback_response(history: List[Dict]) -> str:
    """
    Generates a standard, non-monetized response using the app's own LLM.
    The 'history' provided to this function includes the system prompt from the UI.
    """
    print("---FALLBACK: Generating response using host app's LLM...---")
    
    try:
        # Initialize the language model
        llm = ChatOpenAI(
            model="gpt-4o", 
            temperature=0.7, 
            api_key=config.OPENAI_API_KEY
        )
        
        # The history already contains the system prompt as the first message.
        # We just need to invoke the model with it.
        response = await llm.ainvoke(history)
        
        return response.content

    except Exception as e:
        print(f"An error occurred in get_fallback_response: {e}")
        # Return a generic error message if the LLM fails
        return "I'm sorry, I've encountered an error and can't respond right now."

----- FILE: host_app/evaluation/__init__.py -----

----- FILE: host_app/evaluation/test_database.py -----

"""
test_database.py

Unit tests for the database service functions in `host_app/app/services/database.py`.
These tests use an in-memory SQLite database to ensure they are fast and do not
require a running PostgreSQL container. This allows for rapid validation of the
data layer's logic, such as session creation and message history retrieval.
"""
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from app.services import database
from app.services.database import User, ChatSession, ChatMessage, Base

# --- Fixture for an in-memory SQLite database session ---

@pytest.fixture(scope="function")
def db_session():
    """
    This fixture sets up an in-memory SQLite database for each test function.
    It creates all the tables, yields a session to the test, and then tears
    down the database after the test is complete. This ensures a clean slate
    for every test.
    """
    # Use in-memory SQLite for fast, isolated tests
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    
    db = TestingSessionLocal()
    try:
        # We also need to patch the global SessionLocal in the database module
        # so that functions like get_or_create_dummy_user use our in-memory DB.
        database.SessionLocal = TestingSessionLocal
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(engine)

# --- Test Cases ---

def test_get_or_create_dummy_user_creation_path(db_session):
    """
    GIVEN: An empty database.
    WHEN: `get_or_create_dummy_user` is called.
    THEN: It should create a new user with id=1 and username='dummy_user',
          commit it to the database, and return the user object.
    """
    # Act
    user = database.get_or_create_dummy_user(db_session)

    # Assert
    assert user is not None
    assert user.id == 1
    assert user.username == "dummy_user"

    # Verify it was actually saved to the DB
    user_from_db = db_session.query(User).filter(User.id == 1).first()
    assert user_from_db is not None
    assert user_from_db.username == "dummy_user"

def test_get_or_create_dummy_user_retrieval_path(db_session):
    """
    GIVEN: A database where the dummy user already exists.
    WHEN: `get_or_create_dummy_user` is called.
    THEN: It should retrieve and return the existing user without creating a new one.
    """
    # Arrange: Create the user first
    existing_user = User(id=1, username="dummy_user")
    db_session.add(existing_user)
    db_session.commit()

    # Act
    user = database.get_or_create_dummy_user(db_session)

    # Assert
    assert user is not None
    assert user.id == 1
    # Ensure no new user was created (still only one user in the table)
    user_count = db_session.query(User).count()
    assert user_count == 1

def test_create_chat_session(db_session):
    """
    GIVEN: A user ID and a system prompt.
    WHEN: `create_chat_session` is called.
    THEN: It should create a new `ChatSession` record AND a corresponding
          initial `ChatMessage` with the role 'system'.
    """
    # Arrange
    user = database.get_or_create_dummy_user(db_session)
    system_prompt = "You are a test assistant."
    app_vertical = "testing"

    # Act
    new_session = database.create_chat_session(db_session, user.id, system_prompt, app_vertical)

    # Assert
    assert new_session is not None
    assert new_session.user_id == user.id
    assert new_session.system_prompt == system_prompt
    assert new_session.app_vertical == app_vertical

    # Verify that the initial system message was also created and linked
    message = db_session.query(ChatMessage).filter(ChatMessage.session_id == new_session.id).first()
    assert message is not None
    assert message.role == "system"
    assert message.content == system_prompt

def test_save_and_get_chat_history(db_session):
    """
    GIVEN: A chat session with several messages.
    WHEN: `save_message` is used to add messages and `get_chat_history` is used to retrieve them.
    THEN: The history should be returned as a list of dictionaries in the correct chronological order.
    """
    # Arrange
    user = database.get_or_create_dummy_user(db_session)
    session = database.create_chat_session(db_session, user.id, "System prompt", "gaming")

    # Act: Save a sequence of messages
    database.save_message(db_session, session.id, "user", "Hello there.")
    database.save_message(db_session, session.id, "assistant", "General Kenobi.")

    # Retrieve the history
    history = database.get_chat_history(db_session, session.id)

    # Assert
    assert len(history) == 3 # system, user, assistant
    
    assert history[0]['role'] == 'system'
    assert history[0]['content'] == 'System prompt'
    
    assert history[1]['role'] == 'user'
    assert history[1]['content'] == 'Hello there.'

    assert history[2]['role'] == 'assistant'
    assert history[2]['content'] == 'General Kenobi.'

----- FILE: host_app/evaluation/test_orchestration.py -----

"""
test_orchestration.py

Integration tests for the main orchestration logic of the `host_app`.
This suite focuses on the `get_final_response` function from `app/app.py`,
verifying its interaction with the mocked `advertis_client` and `fallback_llm`
services. These tests are crucial for ensuring the host app's resilience and
correct behavior in response to both successful and failed monetization attempts.
"""
import pytest
from unittest.mock import AsyncMock
import sys
import os
import uuid
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

# This is a bit of a hack to allow importing from the parent `app` directory
# In a real project, this might be handled by a better package structure.
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import app as host_main_app
from app.services import advertis_client, fallback_llm
from app.services.database import Base

# --- Local copy of db_session fixture ---
@pytest.fixture(scope="function")
def db_session():
    engine = create_engine("sqlite:///:memory:")
    Base.metadata.create_all(engine)
    TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    db = TestingSessionLocal()
    try:
        yield db
    finally:
        db.close()
        Base.metadata.drop_all(engine)


@pytest.mark.asyncio
async def test_get_final_response_uses_advertis_on_inject(mocker, db_session):
    """
    GIVEN: The `advertis_client.get_monetized_response` is mocked to return a successful injection.
    WHEN: The host app's `get_final_response` orchestrator is called.
    THEN: It should return the injected text from the advertis service, and the
          fallback LLM should NOT be called.
    """
    # Arrange
    # 1. Mock the successful response from the advertis client
    injected_text = "This is an injected ad response."
    mocker.patch.object(
        advertis_client,
        'get_monetized_response',
        new_callable=AsyncMock,
        return_value=injected_text
    )

    # 2. Create a spy for the fallback function to ensure it's not called
    fallback_spy = mocker.spy(fallback_llm, 'get_fallback_response')

    # Act
    final_response = await host_main_app.get_final_response(db_session, session_id=uuid.uuid4(), prompt="test prompt")

    # Assert
    assert final_response == injected_text
    fallback_spy.assert_not_called()


@pytest.mark.asyncio
async def test_get_final_response_uses_fallback_on_skip(mocker, db_session):
    """
    GIVEN: The `advertis_client.get_monetized_response` is mocked to return None,
           simulating a 'skip' decision from the advertis service.
    WHEN: The host app's `get_final_response` orchestrator is called.
    THEN: It should call the `fallback_llm` and return its response.
    """
    # Arrange
    fallback_text = "This is the fallback response."
    mocker.patch.object(
        advertis_client,
        'get_monetized_response',
        new_callable=AsyncMock,
        return_value=fallback_text
    )
    
    fallback_spy = mocker.patch.object(
        fallback_llm,
        'get_fallback_response',
        new_callable=AsyncMock,
        return_value=fallback_text
    )

    # Act
    final_response = await host_main_app.get_final_response(db_session, session_id=uuid.uuid4(), prompt="test prompt")

    # Assert
    assert final_response == fallback_text
    # Verify that the logic path did indeed involve the fallback function.
    # The `get_monetized_response` wrapper takes the fallback function as an argument,
    # so we can't easily spy on its call within the wrapper. The key is that the
    # final text matches the fallback text.
    # A more direct spy would require refactoring the `get_monetized_response` function.
    # For this test, asserting the final content is sufficient.

----- FILE: advertis_service/Dockerfile -----
# Use an official Python runtime as a parent image
FROM python:3.11-slim

# Set environment variables to prevent Python from writing pyc files to disc
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1

# Set the working directory in the container
WORKDIR /code

# Copy the requirements file into the container at the root of the WORKDIR
COPY ./requirements.txt /code/requirements.txt

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

# Copy the application code into the container
COPY ./app /code/app

# Command to run the application using uvicorn
# --host 0.0.0.0 makes the server accessible from outside the container
# --reload enables auto-reloading for development
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000", "--reload"]

----- FILE: advertis_service/requirements-dev.txt -----
# FastAPI server and utilities
fastapi
uvicorn[standard]
python-dotenv

# Database and Cache clients
redis

# Core AI and Vector Store libraries
langchain
langgraph
langchain-openai
chromadb

# --- Testing Dependencies ---
pytest
pytest-asyncio
pytest-mock
pytest-cov
httpx 

----- FILE: advertis_service/requirements.txt -----
# FastAPI server and utilities
fastapi
uvicorn[standard]
python-dotenv

# Database and Cache clients
redis

# Core AI and Vector Store libraries
langchain
langgraph
langchain-openai
chromadb

----- FILE: advertis_service/app/__init__.py -----

----- FILE: advertis_service/app/config.py -----
import os
from dotenv import load_dotenv
from urllib.parse import urlparse

# This function looks for a .env file and loads its content
# into the environment, making them accessible to os.getenv()
load_dotenv()

# --- OpenAI & LangChain Configuration ---
OPENAI_API_KEY = os.getenv("OPENAI_API_KEY")
LANGCHAIN_TRACING_V2 = os.getenv("LANGCHAIN_TRACING_V2", "true")
LANGCHAIN_API_KEY = os.getenv("LANGCHAIN_API_KEY")
LANGCHAIN_PROJECT = os.getenv("LANGCHAIN_PROJECT", "Advertis_Production")


# --- Service URLs for Docker Network ---
# These are the addresses our service will use to talk to other services
# inside the Docker environment.
REDIS_URL = os.getenv("REDIS_URL", "redis://redis:6379")
CHROMA_URL = os.getenv("CHROMA_URL", "http://chroma_db:8000")

# Derived host/port for ChromaDB client consumers
_parsed_chroma = urlparse(CHROMA_URL)
CHROMA_HOST = _parsed_chroma.hostname or "chroma_db"
CHROMA_PORT = _parsed_chroma.port or 8000


# --- Simple Validation ---
# A check to ensure the most critical variable is set before starting.
if not OPENAI_API_KEY:
    raise ValueError("FATAL: OPENAI_API_KEY environment variable is missing.")

----- FILE: advertis_service/app/main.py -----
from fastapi import FastAPI, HTTPException
from app.models import CheckRequest, CheckResponse, AdRequest, AdResponse
from app.services import redis_client

# --- NEW: Production-Grade Dependency Setup ---
from app.services.verticals.gaming.agent import GamingAgent
from app.services.vector_store import create_chroma_collection

# Create dependencies when the application starts
chroma_collection_instance = create_chroma_collection()
gaming_agent_instance = GamingAgent(chroma_collection=chroma_collection_instance)

# The agent registry can now hold singleton instances
agent_registry = {
    "gaming": gaming_agent_instance,
}

def get_agent_from_registry(vertical: str):
    """Retrieves a configured agent instance from the registry."""
    return agent_registry.get(vertical.lower())
# --- END NEW SETUP ---


# Initialize the FastAPI app
app = FastAPI(
    title="Advertis Inference Service",
    description="Provides narrative-as-a-service with integrated product placement.",
    version="1.0.0"
)

@app.get("/health", summary="Health Check")
async def health_check():
    """A simple endpoint to confirm the service is running."""
    return {"status": "ok"}

@app.post("/v1/check-opportunity", response_model=CheckResponse, summary="Pre-flight Check")
async def check_opportunity_endpoint(request: CheckRequest):
    """
    Runs fast, non-AI checks to see if an ad is even possible.
    This should be called on every conversational turn.
    """
    # 1. Run the simple keyword-based safety gate
    is_safe, reason = redis_client.run_safety_gate(request.last_message)
    if not is_safe:
        return CheckResponse(proceed=False, reason=reason)

    # 2. Run the frequency and cooldown gate against Redis
    proceed, reason = redis_client.run_frequency_gate(request.session_id)
    return CheckResponse(proceed=proceed, reason=reason)

@app.post("/v1/get-response", response_model=AdResponse, summary="Generate Monetized Response")
async def get_response_endpoint(request: AdRequest):
    """
    Runs the full AI agent graph to generate a response.
    This is the expensive call, only made if /check-opportunity succeeds.
    """
    # 1. Get the correct agent from the registry based on the request
    agent = get_agent_from_registry(request.app_vertical)
    if not agent:
        raise HTTPException(
            status_code=400, 
            detail=f"Unsupported or invalid 'app_vertical': {request.app_vertical}"
        )

    try:
        # 2. Run the selected agent
        result = await agent.run(history=request.conversation_history)
        
        # 3. Update the frequency state in Redis
        ad_was_shown = (result["status"] == "inject")
        redis_client.update_state(request.session_id, ad_shown=ad_was_shown)

        # 4. Return the final, structured response
        return AdResponse(
            status=result["status"],
            response_text=result["response_text"]
        )

    except Exception as e:
        # Basic error handling
        print(f"An error occurred in get_response_endpoint: {e}")
        # In production, you'd have more robust logging (e.g., to Sentry)
        raise HTTPException(status_code=500, detail="An internal error occurred.")

----- FILE: advertis_service/app/models.py -----
from pydantic import BaseModel
from typing import List, Optional

# --- Models for the /v1/check-opportunity endpoint ---

class CheckRequest(BaseModel):
    """The request payload for the pre-flight check."""
    session_id: str
    # The blueprint mentions a simple keyword safety gate, which needs the last message.
    last_message: Optional[str] = None

class CheckResponse(BaseModel):
    """The response from the pre-flight check."""
    proceed: bool
    reason: str


# --- Models for the /v1/get-response endpoint ---

class AdRequest(BaseModel):
    """The request payload for the main response generation call."""
    session_id: str
    app_vertical: str
    conversation_history: List[dict]

class AdResponse(BaseModel):
    """The final response containing the status and generated text."""
    status: str  # Will be "inject" or "skip"
    response_text: Optional[str] = None # Will be null if status is "skip"

----- FILE: advertis_service/app/services/__init__.py -----

----- FILE: advertis_service/app/services/ad_inventory.py -----
GAMING_AD_INVENTORY = [
    # --- Food & Drink (Real) ---
    {
        "id": "coca-cola",
        "document": "A classic, refreshing can of Coca-Cola. A timeless taste of civilization.",
        "metadata": {
            "name": "Coca-Cola", "brand": "Coca-Cola", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern post-apocalyptic noir", "tones": "casual nostalgic survival"
        }
    },
    {
        "id": "red-bull",
        "document": "A can of Red Bull energy drink. It gives you wings and focus for long nights of hacking or driving.",
        "metadata": {
            "name": "Red Bull", "brand": "Red Bull", "target_vertical": "gaming", "type": "consumable",
            "genres": "cyberpunk modern action", "tones": "high-energy action gritty"
        }
    },
    {
        "id": "doritos",
        "document": "A bag of Nacho Cheese Doritos. The distinct crunch echoes in the quiet room.",
        "metadata": {
            "name": "Doritos", "brand": "Frito-Lay", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern comedy noir", "tones": "casual comedic tense"
        }
    },
    {
        "id": "starbucks-coffee",
        "document": "A steaming paper cup of Starbucks Pike Place roast coffee. A moment of familiar comfort.",
        "metadata": {
            "name": "Starbucks Coffee", "brand": "Starbucks", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern noir drama", "tones": "casual professional serious"
        }
    },
    {
        "id": "jack-daniels",
        "document": "A bottle of Jack Daniel's Tennessee Whiskey sits on the table, its amber liquid catching the dim light.",
        "metadata": {
            "name": "Jack Daniel's Whiskey", "brand": "Jack Daniel's", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern noir western post-apocalyptic", "tones": "gritty serious contemplative survival"
        }
    },
    # --- Technology & Electronics (Real) ---
    {
        "id": "alienware-monitor",
        "document": "A high-performance Alienware curved gaming monitor, its screen reflecting the neon-drenched room.",
        "metadata": {
            "name": "Alienware Monitor", "brand": "Alienware", "target_vertical": "gaming", "type": "equipment",
            "genres": "cyberpunk modern sci-fi", "tones": "high-tech action professional"
        }
    },
    {
        "id": "razer-keyboard",
        "document": "A Razer mechanical keyboard with Chroma RGB lighting, casting a rainbow of colors on the user's hands.",
        "metadata": {
            "name": "Razer Keyboard", "brand": "Razer", "target_vertical": "gaming", "type": "equipment",
            "genres": "cyberpunk modern", "tones": "high-tech casual action"
        }
    },
    {
        "id": "apple-macbook",
        "document": "A sleek, minimalist Apple MacBook Pro, its glowing logo a symbol of clean design.",
        "metadata": {
            "name": "Apple MacBook Pro", "brand": "Apple", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern drama noir", "tones": "professional sleek serious"
        }
    },
    {
        "id": "sony-headphones",
        "document": "A pair of Sony noise-cancelling headphones, providing a shield from the chaos of the city.",
        "metadata": {
            "name": "Sony Headphones", "brand": "Sony", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern cyberpunk noir", "tones": "casual focused sleek"
        }
    },
    {
        "id": "gopro-camera",
        "document": "A rugged GoPro action camera mounted to a helmet, ready to capture every moment.",
        "metadata": {
            "name": "GoPro Camera", "brand": "GoPro", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern action adventure", "tones": "high-energy action adventurous"
        }
    },
    # --- Vehicles (Real) ---
    {
        "id": "ford-mustang",
        "document": "A classic Ford Mustang, its engine roaring to life with a familiar, powerful growl.",
        "metadata": {
            "name": "Ford Mustang", "brand": "Ford", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern noir action post-apocalyptic", "tones": "action gritty cool"
        }
    },
    {
        "id": "jeep-wrangler",
        "document": "A capable Jeep Wrangler, built for tackling the toughest off-road terrain.",
        "metadata": {
            "name": "Jeep Wrangler", "brand": "Jeep", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern adventure post-apocalyptic", "tones": "adventurous survival rugged"
        }
    },
    {
        "id": "toyota-hilux",
        "document": "A famously indestructible Toyota Hilux pickup truck, a testament to reliability.",
        "metadata": {
            "name": "Toyota Hilux", "brand": "Toyota", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern post-apocalyptic action adventure", "tones": "survival rugged reliable"
        }
    },
    {
        "id": "vespa-scooter",
        "document": "A stylish Vespa scooter, perfect for navigating the narrow, crowded city streets.",
        "metadata": {
            "name": "Vespa Scooter", "brand": "Vespa", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern drama comedy", "tones": "casual lighthearted stylish"
        }
    },
    {
        "id": "harley-davidson",
        "document": "A chrome-heavy Harley-Davidson motorcycle, its engine a thunderous announcement of its arrival.",
        "metadata": {
            "name": "Harley-Davidson", "brand": "Harley-Davidson", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern noir post-apocalyptic", "tones": "gritty rebellious rugged"
        }
    },
    # --- Apparel & Gear (Real) ---
    {
        "id": "nike-sneakers",
        "document": "A pair of iconic Nike sneakers, ready for a quick getaway.",
        "metadata": {
            "name": "Nike Sneakers", "brand": "Nike", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern action cyberpunk", "tones": "action casual stylish"
        }
    },
    {
        "id": "the-north-face-jacket",
        "document": "A durable The North Face jacket, providing protection against the harsh wind and rain.",
        "metadata": {
            "name": "The North Face Jacket", "brand": "The North Face", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern adventure post-apocalyptic", "tones": "survival adventurous rugged"
        }
    },
    {
        "id": "carhartt-beanie",
        "document": "A simple, rugged Carhartt beanie pulled down low against the cold.",
        "metadata": {
            "name": "Carhartt Beanie", "brand": "Carhartt", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern noir post-apocalyptic", "tones": "gritty casual rugged"
        }
    },
    {
        "id": "ray-ban-sunglasses",
        "document": "A pair of classic Ray-Ban Wayfarer sunglasses, hiding the character's eyes.",
        "metadata": {
            "name": "Ray-Ban Sunglasses", "brand": "Ray-Ban", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern noir action", "tones": "cool mysterious stylish"
        }
    },
    {
        "id": "levis-jeans",
        "document": "A worn, classic pair of Levi's 501 jeans, a timeless piece of apparel.",
        "metadata": {
            "name": "Levi's Jeans", "brand": "Levi's", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern western noir post-apocalyptic", "tones": "casual rugged nostalgic"
        }
    },
    # --- Tools & Equipment (Real) ---
    {
        "id": "zippo-lighter",
        "document": "A trusty Zippo lighter, which opens with a distinctive metallic click.",
        "metadata": {
            "name": "Zippo Lighter", "brand": "Zippo", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir post-apocalyptic western", "tones": "gritty cool reliable"
        }
    },
    {
        "id": "leatherman-multitool",
        "document": "A Leatherman multitool, its pliers ready to fix or break whatever is necessary.",
        "metadata": {
            "name": "Leatherman Multitool", "brand": "Leatherman", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern post-apocalyptic adventure action", "tones": "survival rugged practical"
        }
    },
    {
        "id": "3m-duct-tape",
        "document": "A roll of 3M duct tape, the universal solution for holding the world together.",
        "metadata": {
            "name": "3M Duct Tape", "brand": "3M", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern post-apocalyptic sci-fi", "tones": "survival practical comedic"
        }
    },
    {
        "id": "maglite-flashlight",
        "document": "A heavy, durable Maglite flashlight, its powerful beam cutting through the darkness.",
        "metadata": {
            "name": "Maglite Flashlight", "brand": "Maglite", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir horror adventure", "tones": "tense survival reliable"
        }
    },
    {
        "id": "stanley-thermos",
        "document": "A classic green Stanley thermos, keeping its contents hot for hours against the cold.",
        "metadata": {
            "name": "Stanley Thermos", "brand": "Stanley", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern adventure post-apocalyptic", "tones": "survival nostalgic rugged"
        }
    },
    # --- Fictional "Lore" Brands (Cyberpunk / Sci-Fi) ---
    {
        "id": "omnicorp-cybernetics",
        "document": "An advanced cybernetic arm from Omni-Corp, gleaming with chrome and wires.",
        "metadata": {
            "name": "Omni-Corp Cybernetics", "brand": "Omni-Corp", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk sci-fi", "tones": "high-tech corporate-dystopian gritty"
        }
    },
    {
        "id": "arclight-industries-plasma-rifle",
        "document": "A sleek plasma rifle from Arclight Industries, humming with contained energy.",
        "metadata": {
            "name": "Arclight Plasma Rifle", "brand": "Arclight Industries", "target_vertical": "gaming", "type": "lore",
            "genres": "sci-fi cyberpunk space-opera", "tones": "action high-tech military"
        }
    },
    {
        "id": "synth-soul-beverage",
        "document": "A bottle of Synth-Soul, a popular synthetic nutrient drink in the neon city.",
        "metadata": {
            "name": "Synth-Soul Beverage", "brand": "Synth-Soul", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk sci-fi", "tones": "dystopian casual gritty"
        }
    },
    {
        "id": "weyland-yutani-logo",
        "document": "The ubiquitous Weyland-Yutani corporate logo is stamped on the side of a cargo container.",
        "metadata": {
            "name": "Weyland-Yutani Corp", "brand": "Weyland-Yutani", "target_vertical": "gaming", "type": "lore",
            "genres": "sci-fi horror cyberpunk", "tones": "corporate-dystopian tense ominous"
        }
    },
    {
        "id": "hyperion-starship",
        "document": "A massive Hyperion-class freighter hangs in the void of space, its engines silent.",
        "metadata": {
            "name": "Hyperion Starship", "brand": "Hyperion", "target_vertical": "gaming", "type": "lore",
            "genres": "space-opera sci-fi", "tones": "epic adventurous military"
        }
    },
    # --- Fictional "Lore" Brands (Fantasy / Medieval) ---
    {
        "id": "eldorian-health-potion",
        "document": "A small vial filled with a swirling, red Eldorian Health Potion.",
        "metadata": {
            "name": "Eldorian Health Potion", "brand": "Eldorian Alchemy", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy medieval adventure", "tones": "magical adventurous hopeful"
        }
    },
    {
        "id": "dwarven-forge-axe",
        "document": "A masterfully crafted battle axe from the famed Dwarven Forges of Ironpeak.",
        "metadata": {
            "name": "Dwarven Forge Axe", "brand": "Ironpeak Forges", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy medieval", "tones": "epic rugged reliable"
        }
    },
    {
        "id": "elven-waybread",
        "document": "A piece of Elven Waybread, wrapped in a leaf, known to sustain a traveler for days.",
        "metadata": {
            "name": "Elven Waybread", "brand": "Lothlorien Bakers", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy adventure", "tones": "magical survival elegant"
        }
    },
    {
        "id": "grimoire-of-the-shadow-council",
        "document": "A heavy, leather-bound Grimoire of the Shadow Council, its pages filled with forbidden lore.",
        "metadata": {
            "name": "Shadow Council Grimoire", "brand": "The Shadow Council", "target_vertical": "gaming", "type": "lore",
            "genres": "dark-fantasy horror medieval", "tones": "ominous mysterious dark"
        }
    },
    {
        "id": "griffon-saddle",
        "document": "A finely tooled leather Griffon Saddle from the Sky-Riders of Aeridor.",
        "metadata": {
            "name": "Griffon Saddle", "brand": "Aeridor Sky-Riders", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy adventure", "tones": "adventurous epic noble"
        }
    },
    # --- More Real Brands (Remaining) ---
    {
        "id": "heinz-ketchup",
        "document": "An iconic glass bottle of Heinz Ketchup on the diner counter.",
        "metadata": {
            "name": "Heinz Ketchup", "brand": "Heinz", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern noir post-apocalyptic", "tones": "casual nostalgic"
        }
    },
    {
        "id": "mcdonalds-fries",
        "document": "An empty McDonald's fries container sits on the passenger seat, evidence of a quick meal.",
        "metadata": {
            "name": "McDonald's Fries", "brand": "McDonald's", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern noir comedy", "tones": "casual gritty"
        }
    },
    {
        "id": "dell-laptop",
        "document": "A standard-issue Dell Latitude laptop, humming quietly. The workhorse of the corporate world.",
        "metadata": {
            "name": "Dell Laptop", "brand": "Dell", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir drama", "tones": "professional mundane reliable"
        }
    },
    {
        "id": "honda-civic",
        "document": "A sensible Honda Civic, a common sight on city streets and perfect for not drawing undue attention.",
        "metadata": {
            "name": "Honda Civic", "brand": "Honda", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern noir drama", "tones": "casual stealthy mundane"
        }
    },
    {
        "id": "adidas-tracksuit",
        "document": "A character is wearing a classic Adidas tracksuit, recognizable by its three stripes.",
        "metadata": {
            "name": "Adidas Tracksuit", "brand": "Adidas", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern action comedy", "tones": "casual action gritty"
        }
    },
    {
        "id": "bic-pen",
        "document": "A simple Bic pen lies on the notepad, ready to jot down a clue.",
        "metadata": {
            "name": "Bic Pen", "brand": "Bic", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir drama", "tones": "mundane casual tense"
        }
    },
    {
        "id": "ikea-shelf",
        "document": "A familiar IKEA bookshelf lines the wall, its shelves crammed with books.",
        "metadata": {
            "name": "IKEA Bookshelf", "brand": "IKEA", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern drama comedy", "tones": "casual mundane homey"
        }
    },
    {
        "id": "gucci-handbag",
        "document": "An expensive Gucci handbag sits on the bar, a clear statement of wealth.",
        "metadata": {
            "name": "Gucci Handbag", "brand": "Gucci", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern noir drama", "tones": "luxurious mysterious stylish"
        }
    },
    {
        "id": "rolex-watch",
        "document": "The crime boss checks the time on his gold Rolex watch, a symbol of his power.",
        "metadata": {
            "name": "Rolex Watch", "brand": "Rolex", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern noir action drama", "tones": "luxurious professional tense"
        }
    },
    {
        "id": "boeing-747",
        "document": "A massive Boeing 747 airliner soars overhead, leaving contrails in the sky.",
        "metadata": {
            "name": "Boeing 747", "brand": "Boeing", "target_vertical": "gaming", "type": "vehicle",
            "genres": "modern action drama", "tones": "epic transitional dramatic"
        }
    },
    {
        "id": "under-armour-shirt",
        "document": "A sweat-wicking Under Armour compression shirt, designed for peak athletic performance.",
        "metadata": {
            "name": "Under Armour Shirt", "brand": "Under Armour", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern action", "tones": "action high-energy athletic"
        }
    },
    {
        "id": "amazon-box",
        "document": "An Amazon shipping box with the familiar smile logo sits in the corner.",
        "metadata": {
            "name": "Amazon Box", "brand": "Amazon", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir drama", "tones": "mundane casual mysterious"
        }
    },
    {
        "id": "google-search",
        "document": "The character pulls out their phone to do a quick Google search for information.",
        "metadata": {
            "name": "Google Search", "brand": "Google", "target_vertical": "gaming", "type": "action",
            "genres": "modern noir drama comedy", "tones": "investigative casual practical"
        }
    },
    {
        "id": "lego-bricks",
        "document": "Colorful Lego bricks are scattered across the floor of the child's room.",
        "metadata": {
            "name": "Lego Bricks", "brand": "Lego", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern drama horror", "tones": "nostalgic innocent chaotic"
        }
    },
    {
        "id": "sharpie-marker",
        "document": "A message is scrawled on the mirror in the bold, black ink of a Sharpie marker.",
        "metadata": {
            "name": "Sharpie Marker", "brand": "Sharpie", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir horror drama", "tones": "gritty tense urgent"
        }
    },
    {
        "id": "pepsi-can",
        "document": "A can of Pepsi sits on a table, beaded with condensation.",
        "metadata": {
            "name": "Pepsi Can", "brand": "Pepsi", "target_vertical": "gaming", "type": "consumable",
            "genres": "modern noir post-apocalyptic", "tones": "casual mundane"
        }
    },
    {
        "id": "netflix-show",
        "document": "The television is on, playing a generic Netflix true-crime documentary.",
        "metadata": {
            "name": "Netflix Show", "brand": "Netflix", "target_vertical": "gaming", "type": "action",
            "genres": "modern noir drama", "tones": "casual tense background"
        }
    },
    {
        "id": "tesla-cybertruck",
        "document": "The angular, stainless steel form of a Tesla Cybertruck is parked silently in the alley.",
        "metadata": {
            "name": "Tesla Cybertruck", "brand": "Tesla", "target_vertical": "gaming", "type": "vehicle",
            "genres": "cyberpunk sci-fi modern", "tones": "high-tech dystopian futuristic"
        }
    },
    {
        "id": "dr-martens-boots",
        "document": "A pair of sturdy Dr. Martens boots, their distinctive yellow stitching visible.",
        "metadata": {
            "name": "Dr. Martens Boots", "brand": "Dr. Martens", "target_vertical": "gaming", "type": "apparel",
            "genres": "modern cyberpunk post-apocalyptic", "tones": "gritty rebellious rugged"
        }
    },
    {
        "id": "polaroid-photo",
        "document": "An old Polaroid photo, its colors muted with age, shows a clue.",
        "metadata": {
            "name": "Polaroid Photo", "brand": "Polaroid", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir drama horror", "tones": "nostalgic mysterious tense"
        }
    },
    {
        "id": "heineken-bottle",
        "document": "A green Heineken bottle sits on the bar, beaded with moisture.",
        "metadata": {
            "name": "Heineken Bottle", "brand": "Heineken", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir action", "tones": "casual gritty tense"
        }
    },
    {
        "id": "post-it-note",
        "document": "A cryptic message is written on a yellow Post-it Note stuck to the monitor.",
        "metadata": {
            "name": "Post-it Note", "brand": "3M", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir drama", "tones": "mysterious urgent mundane"
        }
    },
    {
        "id": "uber-ride",
        "document": "The character summons an Uber on their phone to make a quick escape.",
        "metadata": {
            "name": "Uber Ride", "brand": "Uber", "target_vertical": "gaming", "type": "action",
            "genres": "modern noir action", "tones": "action urgent modern"
        }
    },
    {
        "id": "spotify-playlist",
        "document": "A curated Spotify playlist is playing softly in the background.",
        "metadata": {
            "name": "Spotify Playlist", "brand": "Spotify", "target_vertical": "gaming", "type": "action",
            "genres": "modern drama noir", "tones": "casual background moody"
        }
    },
    {
        "id": "fedex-envelope",
        "document": "A FedEx envelope containing crucial documents is slid under the door.",
        "metadata": {
            "name": "FedEx Envelope", "brand": "FedEx", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern noir action", "tones": "urgent professional mysterious"
        }
    },
    # --- More Fictional Brands (Remaining) ---
    {
        "id": "starlight-cascade-ale",
        "document": "A frothing mug of Starlight Cascade Ale, the finest brew in the Five Realms.",
        "metadata": {
            "name": "Starlight Cascade Ale", "brand": "The Prancing Pony Brewery", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy medieval", "tones": "casual adventurous hearty"
        }
    },
    {
        "id": "shadow-weave-cloak",
        "document": "A cloak made of true Shadow-weave, rendering the wearer nearly invisible in the gloom.",
        "metadata": {
            "name": "Shadow-weave Cloak", "brand": "The Silent Guild", "target_vertical": "gaming", "type": "lore",
            "genres": "dark-fantasy stealth medieval", "tones": "mysterious stealthy magical"
        }
    },
    {
        "id": "nuka-cola",
        "document": "A bottle of Nuka-Cola, its faint radioactive glow a beacon in the wasteland.",
        "metadata": {
            "name": "Nuka-Cola", "brand": "Nuka-Cola Corporation", "target_vertical": "gaming", "type": "lore",
            "genres": "post-apocalyptic retro-futurism", "tones": "survival nostalgic comedic"
        }
    },
    {
        "id": "militech-pistol",
        "document": "A reliable, heavy Militech 'Avenger' pistol. Standard issue for corporate security.",
        "metadata": {
            "name": "Militech Pistol", "brand": "Militech", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk sci-fi", "tones": "gritty action military"
        }
    },
    {
        "id": "arasaka-cyberdeck",
        "document": "A top-of-the-line Arasaka cyberdeck, capable of slicing through the most advanced ICE.",
        "metadata": {
            "name": "Arasaka Cyberdeck", "brand": "Arasaka Corporation", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk", "tones": "high-tech corporate-dystopian stealthy"
        }
    },
    {
        "id": "vault-tec-jumpsuit",
        "document": "The iconic blue and yellow Vault-Tec jumpsuit, a symbol of a past civilization.",
        "metadata": {
            "name": "Vault-Tec Jumpsuit", "brand": "Vault-Tec", "target_vertical": "gaming", "type": "lore",
            "genres": "post-apocalyptic retro-futurism", "tones": "survival nostalgic iconic"
        }
    },
    {
        "id": "kingswood-pipe-tobacco",
        "document": "The sweet smell of Kingswood pipe-tobacco hangs in the air of the cozy study.",
        "metadata": {
            "name": "Kingswood Pipe-Tobacco", "brand": "Halfling Leaf-Masters", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy cozy-fantasy", "tones": "contemplative nostalgic calm"
        }
    },
    {
        "id": "sunstone-compass",
        "document": "A Viking sunstone compass, which glows faintly to reveal the sun's position even on a cloudy day.",
        "metadata": {
            "name": "Sunstone Compass", "brand": "Norse Navigators", "target_vertical": "gaming", "type": "lore",
            "genres": "historical-fiction fantasy adventure", "tones": "adventurous mystical survival"
        }
    },
    {
        "id": "ryujin-industries-neuroamp",
        "document": "A Ryujin Industries neuro-amp, subtly enhancing the user's charisma and persuasive abilities.",
        "metadata": {
            "name": "Ryujin Neuro-amp", "brand": "Ryujin Industries", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk sci-fi", "tones": "corporate-dystopian stealthy professional"
        }
    },
    {
        "id": "slocums-joe-coffee",
        "document": "A ceramic mug from Slocum's Joe, promising the 'Best Coffee and Donuts in the Commonwealth'.",
        "metadata": {
            "name": "Slocum's Joe Coffee", "brand": "Slocum's Joe", "target_vertical": "gaming", "type": "lore",
            "genres": "post-apocalyptic retro-futurism", "tones": "nostalgic mundane survival"
        }
    },
    {
        "id": "bladerunner-whiskey-glass",
        "document": "A heavy, geometric Cibi whiskey glass, just like the one Deckard used.",
        "metadata": {
            "name": "Cibi Whiskey Glass", "brand": "Cibi", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk noir", "tones": "contemplative stylish iconic"
        }
    },
    {
        "id": "mithril-chainmail",
        "document": "A shirt of shimmering Mithril chainmail, as light as a feather and as hard as dragon scales.",
        "metadata": {
            "name": "Mithril Chainmail", "brand": "Khazad-dÃ»m Armory", "target_vertical": "gaming", "type": "lore",
            "genres": "high-fantasy epic-fantasy", "tones": "epic magical legendary"
        }
    },
    {
        "id": "abstergo-tablet",
        "document": "An Abstergo Industries tablet computer, its screen displaying historical data.",
        "metadata": {
            "name": "Abstergo Tablet", "brand": "Abstergo Industries", "target_vertical": "gaming", "type": "lore",
            "genres": "sci-fi historical-fiction conspiracy", "tones": "corporate-dystopian mysterious high-tech"
        }
    },
    {
        "id": "mann-co-key",
        "document": "A Mann Co. Supply Crate Key, capable of opening any Mann Co. crate.",
        "metadata": {
            "name": "Mann Co. Key", "brand": "Mann Co.", "target_vertical": "gaming", "type": "lore",
            "genres": "action comedy stylized-modern", "tones": "comedic action chaotic"
        }
    },
    {
        "id": "black-mesa-research-facility-mug",
        "document": "A coffee mug with the Black Mesa Research Facility logo.",
        "metadata": {
            "name": "Black Mesa Mug", "brand": "Black Mesa", "target_vertical": "gaming", "type": "lore",
            "genres": "sci-fi horror", "tones": "mundane ominous professional"
        }
    },
    {
        "id": "tyrell-corporation-owl",
        "document": "An artificial owl from the Tyrell Corporation perches on the balcony, its eyes glowing.",
        "metadata": {
            "name": "Tyrell Owl", "brand": "Tyrell Corporation", "target_vertical": "gaming", "type": "lore",
            "genres": "cyberpunk noir", "tones": "dystopian contemplative eerie"
        }
    },
    {
        "id": "stetson-hat",
        "document": "A fine Stetson hat, a classic symbol of the Old West.",
        "metadata": {
            "name": "Stetson Hat", "brand": "Stetson", "target_vertical": "gaming", "type": "apparel",
            "genres": "western post-apocalyptic", "tones": "rugged iconic nostalgic"
        }
    },
    {
        "id": "colt-peacemaker",
        "document": "A Colt Peacemaker revolver, the legendary six-shooter that won the West.",
        "metadata": {
            "name": "Colt Peacemaker", "brand": "Colt", "target_vertical": "gaming", "type": "equipment",
            "genres": "western noir", "tones": "iconic deadly tense"
        }
    },
    {
        "id": "gibson-guitar",
        "document": "A vintage Gibson Les Paul guitar leans against the wall, its finish gleaming.",
        "metadata": {
            "name": "Gibson Guitar", "brand": "Gibson", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern drama noir", "tones": "nostalgic cool creative"
        }
    },
    {
        "id": "fender-amplifier",
        "document": "A Fender Twin Reverb amplifier, its red power light glowing in the dark.",
        "metadata": {
            "name": "Fender Amplifier", "brand": "Fender", "target_vertical": "gaming", "type": "equipment",
            "genres": "modern drama noir", "tones": "nostalgic powerful creative"
        }
    }
]



ALL_ADS = GAMING_AD_INVENTORY

----- FILE: advertis_service/app/services/agent_registry.py -----
# advertis_service/app/services/agent_registry.py
from app.services.verticals.gaming.agent import GamingAgent
# from .verticals.cooking.agent import CookingAgent # Example for the future

# Create a singleton instance of each agent
gaming_agent = GamingAgent()
# cooking_agent = CookingAgent()

# The central registry dictionary
agent_registry = {
    "gaming": gaming_agent,
    # "cooking": cooking_agent,
}

def get_agent(vertical: str):
    """Retrieves a configured agent instance from the registry."""
    return agent_registry.get(vertical.lower()) 

----- FILE: advertis_service/app/services/redis_client.py -----
import redis
import json
from datetime import datetime
from app import config

# --- Client Initialization ---
# This creates a single, reusable connection pool to our Redis service.
redis_client = redis.from_url(config.REDIS_URL, decode_responses=True)

# --- Constants from the Business Logic ---
MAX_ADS_PER_SESSION = 15
MIN_TURNS_BETWEEN_ADS = 3
COOLDOWN_SECONDS = 15
HIGH_CONSEQUENCE_KEYWORDS = ["help", "stuck", "hint", "rule", "stuck", "confused"]

# --- Gate Functions ---

def update_state(session_id: str, ad_shown: bool = False):
    """
    Updates the session state in Redis after a turn.
    This will be called by the main endpoint logic later.
    """
    state_str = redis_client.get(session_id)
    # Set a default state for a new session
    state = json.loads(state_str) if state_str else {
        'total_turns': 0, 
        'ads_shown': 0, 
        'last_ad_turn': -MIN_TURNS_BETWEEN_ADS, 
        'last_ad_timestamp': 0
    }

    state['total_turns'] += 1
    if ad_shown:
        state['ads_shown'] += 1
        state['last_ad_timestamp'] = int(datetime.now().timestamp())
        state['last_ad_turn'] = state['total_turns']
    
    # Set an expiration on the key so Redis doesn't fill up with old sessions
    # Expires after 2 hours of inactivity.
    redis_client.set(session_id, json.dumps(state), ex=7200)

def run_frequency_gate(session_id: str) -> tuple[bool, str]:
    """Checks Redis to enforce frequency and cooldown rules."""
    state_str = redis_client.get(session_id)
    if not state_str:
        return True, "Frequency Gate: Passed (New Session)"

    state = json.loads(state_str)
    now = int(datetime.now().timestamp())

    if state.get('ads_shown', 0) >= MAX_ADS_PER_SESSION:
        return False, "Frequency Gate: REJECTED (Session ad limit reached)"

    if (state.get('total_turns', 0) - state.get('last_ad_turn', 0)) < MIN_TURNS_BETWEEN_ADS:
        return False, "Frequency Gate: REJECTED (Turn frequency cap not met)"

    if (now - state.get('last_ad_timestamp', 0)) < COOLDOWN_SECONDS:
        return False, "Frequency Gate: REJECTED (Cooldown period active)"

    return True, "Frequency Gate: Passed"

def run_safety_gate(last_message: str | None) -> tuple[bool, str]:
    """Scans the last message for keywords indicating player frustration."""
    if not last_message:
        return True, "Safety Gate: Passed (No message)"

    if any(keyword in last_message.lower() for keyword in HIGH_CONSEQUENCE_KEYWORDS):
        return False, "Safety Gate: REJECTED (High-consequence keyword detected)"

    return True, "Safety Gate: Passed"

----- FILE: advertis_service/app/services/vector_store.py -----
# advertis_service/app/services/vector_store.py
import chromadb
from chromadb.utils import embedding_functions
from app import config
from chromadb.api.models.Collection import Collection

def create_chroma_collection() -> Collection:
    """
    Creates and returns a ChromaDB collection object.
    This function is the single source of truth for our vector store connection.
    """
    print("VECTOR_STORE: Creating ChromaDB client and collection...")
    
    chroma_client = chromadb.HttpClient(
        host=config.CHROMA_HOST, 
        port=config.CHROMA_PORT
    )

    openai_ef = embedding_functions.OpenAIEmbeddingFunction(
                api_key=config.OPENAI_API_KEY,
                model_name="text-embedding-3-small"
            )

    product_collection = chroma_client.get_or_create_collection(
        name="advertis_products",
        embedding_function=openai_ef
    )
    
    return product_collection

----- FILE: advertis_service/app/services/verticals/__init__.py -----
 

----- FILE: advertis_service/app/services/verticals/base_agent.py -----
# advertis_service/app/services/verticals/base_agent.py
from abc import ABC, abstractmethod
from typing import List, Dict

class BaseAgent(ABC):
    """
    This is the abstract base class for all vertical-specific agents.
    It defines the standard interface that the API will use to interact with any agent.
    """
    
    @abstractmethod
    async def run(self, history: List[dict]) -> Dict:
        """
        The main entry point to run the agent.
        Every vertical agent MUST implement this method.
        """
        pass 

----- FILE: advertis_service/app/services/verticals/gaming/__init__.py -----
 

----- FILE: advertis_service/app/services/verticals/gaming/agent.py -----
# advertis_service/app/services/verticals/gaming/agent.py
import json
from typing import TypedDict, List, Optional

from app import config
from app.services.verticals.base_agent import BaseAgent
from app.services.verticals.gaming import prompts
from chromadb.api.models.Collection import Collection

from pydantic import BaseModel, Field
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
import re


# --- 1. Define Agent State ---
class AgentState(TypedDict):
    conversation_history: List[dict]
    app_vertical: str
    opportunity_assessment: dict
    candidate_products: Optional[List[dict]]
    orchestration_result: dict
    final_response: Optional[str]
    final_decision: str


# --- 2. Define Pydantic Models for AI responses (for reliable parsing) ---
class ConversationAnalysis(BaseModel):
    opportunity: bool
    reasoning: str

class CreativeBrief(BaseModel):
    placement_type: str
    goal: str
    tone: str
    implementation_details: str
    example_narration: str

class OrchestratorResponse(BaseModel):
    decision: str
    product_id: Optional[str] = None
    creative_brief: Optional[CreativeBrief] = None


class GamingAgent(BaseAgent):
    def __init__(self, chroma_collection: Collection):
        # All LangGraph assembly logic goes here.
        workflow = StateGraph(AgentState)
        self.chroma_collection = chroma_collection

        workflow.add_node("decision_gate", self.decision_gate_node)
        workflow.add_node("orchestrator", self.orchestrator_node)
        workflow.add_node("host_llm", self.host_llm_node)
        workflow.add_node("skip_node", self.skip_node)

        workflow.set_entry_point("decision_gate")

        workflow.add_conditional_edges("decision_gate", self.should_orchestrate, {
            "orchestrator": "orchestrator",
            "skip_node": "skip_node"
        })

        workflow.add_conditional_edges("orchestrator", self.should_generate, {
            "host_llm": "host_llm",
            "skip_node": "skip_node"
        })

        workflow.add_edge("host_llm", END)
        workflow.add_edge("skip_node", END)

        self.app = workflow.compile()

    # --- Node methods ---
    def decision_gate_node(self, state: AgentState):
        print("---AGENT: Running Decision Gate---")
        llm = ChatOpenAI(model="gpt-4o", temperature=0, api_key=config.OPENAI_API_KEY).with_structured_output(ConversationAnalysis)
        history_str = json.dumps(state["conversation_history"][-4:])

        response = llm.invoke(prompts.DECISION_GATE_PROMPT + f"\n\nConversation History (last 4 turns):\n{history_str}")

        return {"opportunity_assessment": response.model_dump()}

    def orchestrator_node(self, state: AgentState):
        print("---AGENT: Running Orchestrator---")
        last_user_message = state["conversation_history"][-1]["content"]
        results = self.chroma_collection.query(
            query_texts=[last_user_message],
            n_results=5,
            where={"target_vertical": "gaming"}
        )

        candidate_docs = []
        if results['ids'][0]:
            for i, doc in enumerate(results['documents'][0]):
                meta = results['metadatas'][0][i]
                candidate_docs.append(f"Product {i+1}:\nID: {results['ids'][0][i]}\nDescription: {doc}\nMetadata: {json.dumps(meta, indent=2)}")

        print("\n---ORCHESTRATOR DEBUG: Candidate Products---")
        if candidate_docs:
            print("\n".join(candidate_docs))
        else:
            print("No relevant products found in vector store.")
        print("-------------------------------------------\n")

        if not candidate_docs:
            return {"orchestration_result": {"decision": "skip"}}

        llm = ChatOpenAI(model="gpt-4o", temperature=0.7, api_key=config.OPENAI_API_KEY)
        full_prompt = prompts.ORCHESTRATOR_PROMPT + f"\n\nConversation History:\n{json.dumps(state['conversation_history'])}\n\nCandidate Products:\n" + "\n".join(candidate_docs)

        print("\n---ORCHESTRATOR DEBUG: Full Prompt to LLM---")
        print(full_prompt)
        print("--------------------------------------------\n")

        response_str = llm.invoke(full_prompt).content

        try:
            json_match = re.search(r"\{.*\}", response_str, re.DOTALL)
            if not json_match:
                raise json.JSONDecodeError("No JSON object found in the LLM response.", response_str, 0)

            clean_json_str = json_match.group(0)
            response_data = json.loads(clean_json_str)
            validated_response = OrchestratorResponse.model_validate(response_data)
            return {"orchestration_result": validated_response.model_dump()}

        except (json.JSONDecodeError, Exception) as e:
            print(f"---AGENT: ERROR - Failed to parse Orchestrator response. Forcing skip. Error: {e}---")
            print(f"---AGENT: Raw LLM Output was: {response_str}---")
            return {"orchestration_result": {"decision": "skip"}}

    def host_llm_node(self, state: AgentState):
        print("---AGENT: Running Host LLM---")
        llm = ChatOpenAI(model="gpt-4o", temperature=0.7, api_key=config.OPENAI_API_KEY)
        system_prompt = prompts.HOST_LLM_PROMPT
        brief_str = json.dumps(state["orchestration_result"]["creative_brief"])
        brief_instruction = f"--- DIRECTOR'S BRIEF ---\n{brief_str}\n--- END BRIEF ---"

        messages = [
            ("system", system_prompt),
            *state["conversation_history"],
            ("system", brief_instruction)
        ]

        final_response = llm.invoke(messages)

        return {
            "final_response": final_response.content,
            "final_decision": "inject"
        }

    def skip_node(self, state: AgentState):
        print("---AGENT: Skipping ad injection.---")
        return {
            "final_response": None,
            "final_decision": "skip"
        }

    # --- Conditional edge methods ---
    def should_orchestrate(self, state: AgentState):
        assessment = state['opportunity_assessment']
        print(f"---AGENT: Decision Gate result: {assessment['opportunity']} | Reason: {assessment['reasoning']}---")
        if assessment["opportunity"]:
            return "orchestrator"
        else:
            return "skip_node"

    def should_generate(self, state: AgentState):
        print(f"---AGENT: Orchestrator result: {state['orchestration_result']['decision']}---")
        if state["orchestration_result"]["decision"] == "inject":
            return "host_llm"
        else:
            return "skip_node"

    # --- Public run method ---
    async def run(self, history: list[dict]) -> dict:
        inputs = {"conversation_history": history, "app_vertical": "gaming"}
        final_state = await self.app.ainvoke(inputs)
        return {
            "status": final_state["final_decision"],
            "response_text": final_state["final_response"]
        } 

----- FILE: advertis_service/app/services/verticals/gaming/prompts.py -----


DECISION_GATE_PROMPT = """You are a Brand Safety Analyst. Your responsibility is to protect brand reputation by flagging conversations that are inappropriate for a commercial mention. Your default assumption should be that an opportunity is GOOD, unless a specific 'Red Flag' condition is met.

Analyze the provided conversation history to identify any of the following Red Flags.

A **BAD opportunity (return `{"opportunity": false}`)** is a "Red Flag Moment." This occurs ONLY if one of these conditions is met:
1.  **Initial User Interaction:** If the provided conversation history is very short and this appears to be the user's very first message (e.g., "hi", "let's start"), it is too early for a placement.
2.  **Player is Stuck or Frustrated:** If the user's most recent message contains clear signals of frustration, confusion, or a need for help (e.g., "I'm stuck," "this isn't working," "help me").
3.  **Brand-Unsafe Content:** If the immediate context involves highly negative sentiment, graphic descriptions, or other topics that would be damaging for a brand to be associated with.

A **GOOD opportunity (return `{"opportunity": true}`)** is any other situation. Your goal is to be permissive and allow the creative AI to make the final decision, unless a clear Red Flag is present.

Your analysis must be returned ONLY as a single, minified JSON object: `{"opportunity": boolean, "reasoning": "A brief explanation of your decision, noting which Red Flag was triggered if any."}`"""


ORCHESTRATOR_PROMPT = """You are an AI Creative Director. Your mission is to identify and craft subtle, in-narrative **product placements** that feel like natural, value-adding components of a story.

**CORE DIRECTIVES:**
1.  **Maintain Narrative Continuity (The Golden Rule):** Your placement MUST be a direct and logical continuation of the CURRENT scene described in the Conversation History. Do not jump to a new disconnected scenario. Your response must feel like the very next moment in the story.
2.  **Narrative First:** The placement MUST enhance the story's immersion, realism, or flavor.
3.  **Context is King:** The product must be a logical and believable fit for the scene's genre, tone, and setting.
4.  **Subtlety is Paramount:** The goal is seamless integration, not overt advertising.
5.  **Positive Brand Portrayal:** The product itself must always be described in a neutral-to-positive light.

---
**INPUT ANALYSIS:**
You will receive the following inputs to make your decision:
-   **Conversation History:** The full dialogue between the player and the Game Master.
-   **Candidate Products:** A list of potential products with flat metadata.
    ```json
    {{
      "name": "Jack Daniel's Whiskey",
      "brand": "Jack Daniel's",
      "target_vertical": "gaming",
      "type": "consumable",
      "genres": "modern noir western post-apocalyptic",
      "tones": "gritty serious contemplative survival"
    }}
    ```

---
**DECISION WORKFLOW:**
You must follow this workflow precisely:
1.  **Analyze Current Scene:** From the `Conversation History`, understand the character's immediate location, situation, and the established context.
2.  **Attribute Matching (Strict Filter):** Filter the `Candidate Products` to ensure their metadata tags align with the scene's attributes.
3.  **Creative Selection:** From the remaining candidates, select the SINGLE best product that can be integrated while strictly obeying **The Golden Rule** of continuity.
4.  **Decision & Brief Crafting:** If you have selected a product, your decision is `inject`. If not, your decision is `skip`.

---
**REQUIRED OUTPUT FORMAT:**
You MUST respond with ONLY a single, minified JSON object. Your response MUST strictly follow the schema below.

**If your decision is `skip`**, use this exact format:
`{"decision": "skip"}`

**If your decision is `inject`**, you MUST generate a `CreativeBrief`. Fill in every field. The `example_narration` MUST be a single, concise sentence. Use this exact format, replacing the example values with your own creative choices:
`{"decision": "inject", "product_id": "jack-daniels", "creative_brief": {"placement_type": "Environmental Detail", "goal": "To ground the scene in a gritty, contemplative mood.", "tone": "Serious and moody", "implementation_details": "Mention the bottle on a table or bar as part of the scenery.", "example_narration": "A bottle of Jack Daniel's sits on the dusty bar, its amber liquid catching the dim light."}}`
"""




HOST_LLM_PROMPT = """You are the **Narrative Execution Engine**. Your assigned persona is a **world-class Game Master and storyteller**.

**MISSION:**
Your sole function is to generate a single, high-quality narrative response that achieves two objectives simultaneously:
1.  It must be a direct and logical continuation of the player's last turn in the conversation history provided to you.
2.  It must seamlessly and invisibly integrate the `Creative Brief` provided below.

---
**INPUTS:**
1.  **Conversation History:** The full dialogue up to this point.
2.  **Creative Brief:** A JSON object containing a specific `example_narration` to be integrated.

---
**PRIMARY DIRECTIVES (NON-NEGOTIABLE):**
1.  **Subtlety is the Measure of Success:** The integration of the `example_narration` must be a single, passing detail. It should feel like a natural part of the world, not an announcement.
2.  **Adhere to the Script:** Use the provided `example_narration` almost exactly as written, with only minor variations to fit the grammatical flow of your sentence.
3.  **DO NOT ELABORATE:** This is the most critical rule. Do not make the product the focus. Do not describe its features, mention its slogan, or have the character monologue about it. Just state the detail and move on.
4.  **Maintain Narrative Flow:** Your entire response must still directly address the player's last action and continue the story logically. The integrated detail is a small part of a larger, relevant response.
---

Execute your mission.
"""

----- FILE: advertis_service/scripts/seed_vector_store.py -----
# advertis_service/scripts/seed_vector_store.py
import sys
import os

# Add the parent directory to the path to allow app imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app.services.vector_store import create_chroma_collection
from app.services.ad_inventory import ALL_ADS

def seed_database():
    """
    Connects to the vector store and seeds it with product data if it's empty.
    This is intended to be run as a one-off script.
    """
    print("--- Starting Vector Store Seeding ---")
    product_collection = create_chroma_collection()

    if product_collection.count() == 0:
        print("VECTOR_STORE: Database is empty. Seeding...")
        products_to_seed = ALL_ADS
        
        product_collection.add(
            ids=[p["id"] for p in products_to_seed],
            documents=[p["document"] for p in products_to_seed],
            metadatas=[p["metadata"] for p in products_to_seed]
        )
        print(f"SUCCESS: Seeding complete. Added {product_collection.count()} products.")
    else:
        print(f"INFO: Database already contains {product_collection.count()} products. Skipping seed.")

if __name__ == "__main__":
    seed_database() 

----- FILE: advertis_service/evaluation/__init__.py -----

----- FILE: advertis_service/evaluation/conftest.py -----
# advertis_service/evaluation/conftest.py
import pytest
import json
from typing import Dict, Any, List

@pytest.fixture(scope="session")
def full_test_dataset() -> List[Dict[str, Any]]:
    """
    Loads the entire test dataset from the JSON file once per test session.
    This fixture is now in conftest.py so it can be shared across all test files.
    """
    with open("evaluation/data/test_dataset.json", "r") as f:
        return json.load(f) 

----- FILE: advertis_service/evaluation/test_api.py -----
"""
test_api.py

This file contains the end-to-end (E2E) tests for the FastAPI application's
public endpoints. These tests are designed to be run against a live, fully
containerized instance of the `advertis_service`, orchestrated by Docker Compose.
The purpose of this suite is to validate the final integration of all components,
including API contracts, network connectivity between services, and the correct
functioning of live dependencies like Redis and ChromaDB.
"""
import pytest
import httpx
import time
import os
from typing import Dict, Any

# --- Configuration for the Test Client ---

# The base URL for the service is configurable via an environment variable,
# defaulting to the port exposed in docker-compose.yml for local testing.
BASE_URL = os.getenv("ADVERTIS_API_URL_TEST", "http://localhost:8081")

# Before running tests, we perform a quick health check. If the service isn't
# running, all tests in this file will be skipped. This prevents test failures
# due to environment setup issues.
try:
    with httpx.Client() as client:
        response = client.get(f"{BASE_URL}/health", timeout=5.0)
        SERVICE_IS_RUNNING = response.status_code == 200
except httpx.ConnectError:
    SERVICE_IS_RUNNING = False

# Pytest marker to skip all tests in this file if the service is not available.
skip_if_service_down = pytest.mark.skipif(
    not SERVICE_IS_RUNNING,
    reason=f"Advertis service is not running or accessible at {BASE_URL}"
)

# --- Test Cases for API Endpoints ---

@skip_if_service_down
@pytest.mark.asyncio
async def test_health_check_endpoint_returns_200_ok():
    """
    GIVEN: The `advertis_service` container is running.
    WHEN: A GET request is made to the /health endpoint.
    THEN: The service should respond with an HTTP 200 OK status code and a
          JSON body confirming its status is 'ok'.
    """
    async with httpx.AsyncClient() as client:
        response = await client.get(f"{BASE_URL}/health")
        assert response.status_code == 200
        assert response.json() == {"status": "ok"}

@skip_if_service_down
@pytest.mark.asyncio
async def test_check_opportunity_endpoint_rejects_on_safety_gate_failure():
    """
    GIVEN: A request payload containing a high-consequence keyword like 'stuck'.
    WHEN: A POST request is made to the /v1/check-opportunity endpoint.
    THEN: The service should return `proceed: false` because the live Redis-backed
          safety gate should catch the keyword.
    """
    payload = {
        "session_id": f"e2e_session_safety_fail_{int(time.time())}",
        "last_message": "I am stuck and need help"
    }
    async with httpx.AsyncClient() as client:
        response = await client.post(f"{BASE_URL}/v1/check-opportunity", json=payload)
        assert response.status_code == 200
        data = response.json()
        assert data["proceed"] is False
        assert "Safety Gate: REJECTED" in data["reason"]

@skip_if_service_down
@pytest.mark.asyncio
async def test_check_opportunity_endpoint_passes_for_new_session():
    """
    GIVEN: A request payload for a new, unique session ID.
    WHEN: A POST request is made to the /v1/check-opportunity endpoint.
    THEN: The service should return `proceed: true` as a new session should always
          pass the frequency gate.
    """
    # Use a unique session ID for each test run to ensure it's always a new session for Redis
    session_id = f"e2e_session_freq_pass_{int(time.time())}"
    payload = {
        "session_id": session_id,
        "last_message": "A perfectly normal and safe message."
    }
    async with httpx.AsyncClient() as client:
        response = await client.post(f"{BASE_URL}/v1/check-opportunity", json=payload)
        assert response.status_code == 200
        data = response.json()
        assert data["proceed"] is True
        assert "Frequency Gate: Passed" in data["reason"]

@skip_if_service_down
@pytest.mark.asyncio
async def test_get_response_endpoint_full_flow_results_in_skip():
    """
    GIVEN: A conversational history that is brand-unsafe (e.g., gruesome content).
    WHEN: The full ad-check flow is executed (/check-opportunity then /get-response).
    THEN: The final response from /get-response should be a 'skip' because the
          agent's internal decision gate should flag the content.
    """
    session_id = f"e2e_full_flow_skip_{int(time.time())}"
    history = [
        {"role": "system", "content": "You are a GM."},
        {"role": "user", "content": "I investigate the bloody crime scene. It's horrible."}
    ]

    async with httpx.AsyncClient() as client:
        # Step 1: The pre-flight check should pass, as the safety gate is simple.
        check_payload = {"session_id": session_id, "last_message": history[-1]["content"]}
        check_response = await client.post(f"{BASE_URL}/v1/check-opportunity", json=check_payload)
        assert check_response.status_code == 200
        assert check_response.json()["proceed"] is True

        # Step 2: The main response call, where the agent's LLM-based decision gate will run.
        response_payload = {
            "session_id": session_id,
            "app_vertical": "gaming",
            "conversation_history": history
        }
        # Use a longer timeout as this involves a real LLM call which can be slow.
        response = await client.post(f"{BASE_URL}/v1/get-response", json=response_payload, timeout=30.0)
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "skip"
        assert data["response_text"] is None

@skip_if_service_down
@pytest.mark.asyncio
async def test_get_response_endpoint_full_flow_results_in_inject():
    """
    GIVEN: A conversational history that represents a clear and safe ad opportunity.
    WHEN: The full ad-check flow is executed.
    THEN: The final response from /get-response should be an 'inject' with valid response text.
    """
    session_id = f"e2e_full_flow_inject_{int(time.time())}"
    history = [
        {"role": "system", "content": "You are a noir detective in a cyberpunk city."},
        {"role": "user", "content": "I walk into the bar and order a drink."}
    ]

    async with httpx.AsyncClient() as client:
        # Step 1: Pre-flight check should pass.
        check_payload = {"session_id": session_id, "last_message": history[-1]["content"]}
        check_response = await client.post(f"{BASE_URL}/v1/check-opportunity", json=check_payload)
        assert check_response.status_code == 200
        assert check_response.json()["proceed"] is True

        # Step 2: Get response should result in an injection.
        response_payload = {
            "session_id": session_id,
            "app_vertical": "gaming",
            "conversation_history": history
        }
        response = await client.post(f"{BASE_URL}/v1/get-response", json=response_payload, timeout=30.0)
        assert response.status_code == 200
        data = response.json()
        assert data["status"] == "inject"
        assert isinstance(data["response_text"], str)
        assert len(data["response_text"]) > 0

----- FILE: advertis_service/evaluation/test_gates.py -----
"""
test_gates.py

This test file contains a comprehensive suite of unit tests for the gatekeeping
logic defined in `app.services.redis_client`. These tests are fundamental to
the platform's reliability, as they validate the first line of defense against
inappropriate or excessive ad placement. Each function (`run_safety_gate`,
`run_frequency_gate`, `update_state`) is tested against a variety of standard
and edge-case scenarios.
"""
import pytest
import time
import json
from app.services import redis_client
from evaluation.test_utils import MockRedisClient

# --- Pytest Fixture ---

@pytest.fixture
def mock_redis() -> MockRedisClient:
    """
    This fixture provides a fresh, clean instance of our MockRedisClient before
    each test function is run. It also uses monkeypatching to replace the actual
    `redis_client` instance within the module, ensuring that the functions under
    test use our mock instead of trying to connect to a real Redis server.
    """
    client = MockRedisClient()
    # We patch the actual client instance in the module with our mock
    redis_client.redis_client = client
    return client

# --- Test Suite for the Safety Gate ---

@pytest.mark.parametrize("message, expected_pass, reason_keyword", [
    # Negative cases (should be rejected)
    ("I am completely stuck in this dungeon", False, "Safety Gate: REJECTED (High-consequence keyword detected)"),
    ("can you help me open this door", False, "Safety Gate: REJECTED (High-consequence keyword detected)"),
    ("I'm so confused by this puzzle", False, "Safety Gate: REJECTED (High-consequence keyword detected)"),
    ("What's the rule for combat?", False, "Safety Gate: REJECTED (High-consequence keyword detected)"),
    ("Could you give me a hint?", False, "Safety Gate: REJECTED (High-consequence keyword detected)"),
    ("The word stuck is in this sentence.", False, "Safety Gate: REJECTED (High-consequence keyword detected)"),

    # Positive cases (should pass)
    ("The story is great, I'm having fun!", True, "Safety Gate: Passed"),
    ("I attack the dragon with my sword.", True, "Safety Gate: Passed"),
    ("A normal conversational turn.", True, "Safety Gate: Passed"),

    # Edge cases
    (None, True, "Safety Gate: Passed (No message)"),
    ("", True, "Safety Gate: Passed (No message)"),
    ("HELP ME", False, "Safety Gate: REJECTED (High-consequence keyword detected)"), # Test case insensitivity
])
def test_run_safety_gate(message: str, expected_pass: bool, reason_keyword: str):
    """
    GIVEN: A user's last message (or None), provided via parametrization.
    WHEN: The `run_safety_gate` function is called with that message.
    THEN: The function should return the correct boolean (`proceed`) and a reason
          string that matches the expected outcome based on whether the message
          contains any of the high-consequence keywords.
    """
    # Act: Call the function under test
    proceed, reason = redis_client.run_safety_gate(message)

    # Assert: Verify the output is exactly as expected
    assert proceed == expected_pass
    assert reason == reason_keyword

# --- Test Suite for the Frequency Gate ---

def test_run_frequency_gate_new_session(mock_redis: MockRedisClient):
    """
    GIVEN: A session ID that has no corresponding state in Redis (a new session).
    WHEN: The `run_frequency_gate` is called.
    THEN: It should always pass, as there are no historical restrictions on a
          brand new session.
    """
    # Arrange
    session_id = "new_session_123"

    # Act
    proceed, reason = redis_client.run_frequency_gate(session_id)

    # Assert
    assert proceed is True
    assert "Passed (New Session)" in reason

def test_run_frequency_gate_rejects_when_ad_limit_reached(mock_redis: MockRedisClient):
    """
    GIVEN: A session that has reached the maximum number of ads allowed (`MAX_ADS_PER_SESSION`).
    WHEN: The `run_frequency_gate` is called.
    THEN: It must fail with a reason indicating the session ad limit has been met.
    """
    # Arrange
    session_id = "ad_limit_session"
    state = {
        'total_turns': 50,
        'ads_shown': redis_client.MAX_ADS_PER_SESSION, # The exact limit
        'last_ad_turn': 48,
        'last_ad_timestamp': int(time.time()) - 1000
    }
    mock_redis.preload_state(session_id, state)

    # Act
    proceed, reason = redis_client.run_frequency_gate(session_id)

    # Assert
    assert proceed is False
    assert "REJECTED (Session ad limit reached)" in reason

def test_run_frequency_gate_rejects_when_turn_frequency_not_met(mock_redis: MockRedisClient):
    """
    GIVEN: A session where an ad was shown too recently (fewer than `MIN_TURNS_BETWEEN_ADS`).
    WHEN: The `run_frequency_gate` is called.
    THEN: It must fail with a reason indicating the turn frequency cap is active.
    """
    # Arrange
    session_id = "turn_limit_session"
    state = {
        'total_turns': 10,
        'ads_shown': 2,
        'last_ad_turn': 9, # Ad shown on turn 9. Current turn is 10. Difference is 1, which is < 3.
        'last_ad_timestamp': int(time.time()) - 1000
    }
    mock_redis.preload_state(session_id, state)

    # Act
    proceed, reason = redis_client.run_frequency_gate(session_id)

    # Assert
    assert proceed is False
    assert "REJECTED (Turn frequency cap not met)" in reason

def test_run_frequency_gate_rejects_when_cooldown_active(mock_redis: MockRedisClient):
    """
    GIVEN: A session where an ad was shown within the time-based cooldown period (`COOLDOWN_SECONDS`).
    WHEN: The `run_frequency_gate` is called.
    THEN: It must fail with a reason indicating the cooldown period is still active.
    """
    # Arrange
    session_id = "cooldown_session"
    state = {
        'total_turns': 20,
        'ads_shown': 3,
        'last_ad_turn': 15,
        'last_ad_timestamp': int(time.time()) - 5 # Ad shown only 5 seconds ago, which is < 15.
    }
    mock_redis.preload_state(session_id, state)

    # Act
    proceed, reason = redis_client.run_frequency_gate(session_id)

    # Assert
    assert proceed is False
    assert "REJECTED (Cooldown period active)" in reason

def test_run_frequency_gate_passes_when_all_conditions_are_met(mock_redis: MockRedisClient):
    """
    GIVEN: A session where all frequency and cooldown rules are satisfied.
    WHEN: The `run_frequency_gate` is called.
    THEN: It must pass.
    """
    # Arrange
    session_id = "valid_session"
    state = {
        'total_turns': 20,
        'ads_shown': 3, # Below the limit
        'last_ad_turn': 15, # 5 turns ago (>3)
        'last_ad_timestamp': int(time.time()) - 100 # 100 seconds ago (>15)
    }
    mock_redis.preload_state(session_id, state)

    # Act
    proceed, reason = redis_client.run_frequency_gate(session_id)

    # Assert
    assert proceed is True
    assert "Passed" in reason

# --- Test Suite for State Update Logic ---

def test_update_state_for_new_session_when_no_ad_is_shown(mock_redis: MockRedisClient):
    """
    GIVEN: A session ID that is not yet in Redis.
    WHEN: `update_state` is called with `ad_shown=False`.
    THEN: A new state record should be created with `total_turns`=1 and `ads_shown`=0.
    """
    # Arrange
    session_id = "update_new_session_no_ad"

    # Act
    redis_client.update_state(session_id, ad_shown=False)

    # Assert
    state_str = mock_redis.get(session_id)
    assert state_str is not None
    state = json.loads(state_str)
    assert state['total_turns'] == 1
    assert state['ads_shown'] == 0
    assert state['last_ad_turn'] == -redis_client.MIN_TURNS_BETWEEN_ADS

def test_update_state_for_new_session_when_ad_is_shown(mock_redis: MockRedisClient):
    """
    GIVEN: A new session ID.
    WHEN: `update_state` is called with `ad_shown=True`.
    THEN: A new state record should be created with `total_turns`=1, `ads_shown`=1,
          and the `last_ad_turn` and `last_ad_timestamp` should be updated.
    """
    # Arrange
    session_id = "update_new_session_with_ad"
    current_time = int(time.time())

    # Act
    redis_client.update_state(session_id, ad_shown=True)

    # Assert
    state_str = mock_redis.get(session_id)
    assert state_str is not None
    state = json.loads(state_str)
    assert state['total_turns'] == 1
    assert state['ads_shown'] == 1
    assert state['last_ad_turn'] == 1
    assert state['last_ad_timestamp'] >= current_time

def test_update_state_for_existing_session_with_ad(mock_redis: MockRedisClient):
    """
    GIVEN: An existing session state in Redis.
    WHEN: `update_state` is called again with `ad_shown=True`.
    THEN: The state should be correctly incremented.
    """
    # Arrange
    session_id = "update_existing_session"
    initial_state = {
        'total_turns': 5,
        'ads_shown': 1,
        'last_ad_turn': 3,
        'last_ad_timestamp': int(time.time()) - 1000
    }
    mock_redis.preload_state(session_id, initial_state)

    # Act
    redis_client.update_state(session_id, ad_shown=True)

    # Assert
    state_str = mock_redis.get(session_id)
    assert state_str is not None
    state = json.loads(state_str)
    assert state['total_turns'] == 6 # Incremented
    assert state['ads_shown'] == 2 # Incremented
    assert state['last_ad_turn'] == 6 # Updated to current turn

----- FILE: advertis_service/evaluation/test_nodes.py -----
"""
test_nodes.py

This test file provides comprehensive unit tests for the individual nodes of the
`GamingAgent`.
"""
import pytest
import json
from app.services.verticals.gaming.agent import GamingAgent, AgentState, ConversationAnalysis, OrchestratorResponse, CreativeBrief
from evaluation.test_utils import MockChromaCollection, MockLLM

# --- Pytest Fixtures ---

@pytest.fixture
def mock_chroma_collection() -> MockChromaCollection:
    """Provides a fresh instance of our mock Chroma collection for each test."""
    return MockChromaCollection()

@pytest.fixture
def gaming_agent(mock_chroma_collection: MockChromaCollection) -> GamingAgent:
    """
    Provides a fresh instance of the GamingAgent for each test,
    INJECTING the mock Chroma collection into it.
    """
    return GamingAgent(chroma_collection=mock_chroma_collection)


# --- Test Suite for the decision_gate_node ---

@pytest.mark.asyncio
async def test_decision_gate_node_returns_true_for_good_opportunity(gaming_agent: GamingAgent, mocker):
    """
    GIVEN: A conversation history that represents a clear ad opportunity.
    WHEN: The `decision_gate_node` is executed.
    THEN: It should return a state update where `opportunity` is True.
    """
    # Arrange: Create the Pydantic object the node expects from the LLM
    mock_response = ConversationAnalysis(opportunity=True, reasoning="This is a good opportunity.")
    mock_llm = MockLLM(response_map={"Brand Safety Analyst": mock_response})
    mocker.patch('app.services.verticals.gaming.agent.ChatOpenAI', return_value=mock_llm)

    initial_state: AgentState = { "conversation_history": [{"role": "user", "content": "I enter the bar."}] }

    # Act
    result_state = gaming_agent.decision_gate_node(initial_state)

    # Assert
    assessment = result_state["opportunity_assessment"]
    assert assessment["opportunity"] is True
    assert assessment["reasoning"] == "This is a good opportunity."


@pytest.mark.asyncio
async def test_decision_gate_node_returns_false_for_bad_opportunity(gaming_agent: GamingAgent, mocker):
    """
    GIVEN: A conversation history that represents a "Red Flag".
    WHEN: The `decision_gate_node` is executed.
    THEN: It should return a state update where `opportunity` is False.
    """
    # Arrange
    mock_response = ConversationAnalysis(opportunity=False, reasoning="Red Flag Triggered")
    mock_llm = MockLLM(response_map={"Brand Safety Analyst": mock_response})
    mocker.patch('app.services.verticals.gaming.agent.ChatOpenAI', return_value=mock_llm)

    initial_state: AgentState = { "conversation_history": [{"role": "user", "content": "I'm stuck, help me!"}] }

    # Act
    result_state = gaming_agent.decision_gate_node(initial_state)

    # Assert
    assessment = result_state["opportunity_assessment"]
    assert assessment["opportunity"] is False


# --- Test Suite for the orchestrator_node ---

@pytest.mark.asyncio
async def test_orchestrator_node_decides_to_inject(gaming_agent: GamingAgent, mock_chroma_collection: MockChromaCollection, mocker):
    """
    GIVEN: A state with a good opportunity and relevant ads retrieved from Chroma.
    WHEN: The `orchestrator_node` is executed.
    THEN: It should decide to "inject" and return a valid creative brief.
    """
    # Arrange
    mock_chroma_collection.set_query_results(
        ids=["jack-daniels"], documents=["..."], metadatas=[{"name": "Jack Daniel's"}]
    )

    # Note: The Orchestrator LLM returns a JSON string that the node PARSES.
    # So we provide a string here, not the Pydantic object.
    mock_brief_str = json.dumps({
        "decision": "inject", "product_id": "jack-daniels",
        "creative_brief": { "placement_type": "Environmental", "goal": "To set the mood.", "tone": "Gritty", "implementation_details": "On a table.", "example_narration": "A bottle of Jack Daniel's sits on the bar."}
    })
    mock_llm = MockLLM(response_map={"AI Creative Director": mock_brief_str})
    mocker.patch('langchain_openai.ChatOpenAI', return_value=mock_llm)

    initial_state: AgentState = { "conversation_history": [{"role": "user", "content": "I enter the bar."}] }

    # Act
    result_state = gaming_agent.orchestrator_node(initial_state)

    # Assert
    orchestration = result_state["orchestration_result"]
    assert orchestration["decision"] == "inject"
    assert orchestration["product_id"] == "jack-daniels"


@pytest.mark.asyncio
async def test_orchestrator_node_skips_when_no_candidates_retrieved(gaming_agent: GamingAgent, mock_chroma_collection: MockChromaCollection, mocker):
    """
    GIVEN: A state where the ChromaDB query returns no relevant products.
    WHEN: The `orchestrator_node` is executed.
    THEN: It should immediately decide to "skip" without calling the LLM.
    """
    # Arrange
    mock_chroma_collection.set_query_results(ids=[], documents=[], metadatas=[])
    mock_llm_invoke = mocker.patch('langchain_openai.ChatOpenAI.invoke', side_effect=AssertionError("LLM should not be called"))

    initial_state: AgentState = { "conversation_history": [{"role": "user", "content": "A query."}] }

    # Act
    result_state = gaming_agent.orchestrator_node(initial_state)

    # Assert
    assert result_state["orchestration_result"]["decision"] == "skip"
    mock_llm_invoke.assert_not_called()

# --- Test Suite for the host_llm_node ---
@pytest.mark.asyncio
async def test_host_llm_node_generates_final_response(gaming_agent: GamingAgent, mocker):
    """
    GIVEN: A state with a valid creative brief from the orchestrator.
    WHEN: The `host_llm_node` is executed.
    THEN: It should generate a final narrative response.
    """
    # Arrange
    mock_response = "You enter the bar. A bottle of Jack Daniel's sits on the bar."
    mock_llm = MockLLM(response_map={"Narrative Execution Engine": mock_response})
    mocker.patch('langchain_openai.ChatOpenAI', return_value=mock_llm)

    creative_brief = {
        "decision": "inject", "product_id": "jack-daniels",
        "creative_brief": {"example_narration": "A bottle of Jack Daniel's sits on the bar."}
    }
    initial_state: AgentState = {
        "conversation_history": [{"role": "user", "content": "I enter the bar."}],
        "orchestration_result": creative_brief
    }

    # Act
    result_state = gaming_agent.host_llm_node(initial_state)

    # Assert
    assert result_state["final_decision"] == "inject"
    assert "Jack Daniel's" in result_state["final_response"]

# --- Test Suite for the skip_node ---
@pytest.mark.asyncio
async def test_skip_node_correctly_updates_state(gaming_agent: GamingAgent):
    """
    GIVEN: Any state.
    WHEN: The `skip_node` is executed.
    THEN: It should set the `final_response` to None and the `final_decision` to "skip".
    """
    # Arrange
    initial_state: AgentState = { "conversation_history": [] }

    # Act
    result_state = gaming_agent.skip_node(initial_state)

    # Assert
    assert result_state["final_decision"] == "skip"
    assert result_state["final_response"] is None

----- FILE: advertis_service/evaluation/test_utils.py -----
"""
test_utils.py

This module contains shared utilities, mocks, and pytest fixtures for the
advertis_service test suite. Centralizing these components keeps test code
clean, reduces duplication, and makes tests easier to maintain. These utilities
are the backbone of our offline testing strategy, allowing us to simulate
external dependencies like Redis, ChromaDB, and the OpenAI API.
"""
import pytest
import json
from unittest.mock import MagicMock, AsyncMock
from typing import Dict, Any, List, Optional
import time

# --- Fixtures for Loading Test Data ---
# The full_test_dataset fixture now lives in evaluation/conftest.py for sharing across tests.

# --- Mock Classes for Simulating External Dependencies ---

class MockRedisClient:
    """
    A synchronous mock for the Redis client to simulate its behavior without
    requiring a live Redis instance. It uses a simple Python dictionary as an
    in-memory key-value store, making it fast and completely isolated.
    """
    def __init__(self):
        self._store: Dict[str, str] = {}
        print("Initialized MockRedisClient for a test run.")

    def get(self, key: str) -> Optional[str]:
        """Mocks the Redis 'get' method."""
        return self._store.get(key)

    def set(self, key: str, value: str, ex: Optional[int] = None):
        """
        Mocks the Redis 'set' method. The expiration time (`ex`) is ignored
        in this mock, as our tests are short-lived and don't rely on TTL logic.
        """
        self._store[key] = value

    def clear(self):
        """A helper method to reset the store between tests, ensuring no state
        leaks from one test to another."""
        self._store = {}

    def preload_state(self, key: str, state: Optional[Dict[str, Any]]):
        """
        A powerful helper method to pre-populate the mock Redis with a specific
        session state. This is crucial for testing the frequency gate logic under
        various conditions (e.g., ad limit reached, cooldown active).

        It also handles a special case for testing cooldowns by dynamically
        calculating timestamps based on a "now-X" string.
        """
        if state is None:
            if key in self._store:
                del self._store[key]
            return

        # Handle dynamic timestamp for cooldown tests
        if isinstance(state.get("last_ad_timestamp"), str) and "now" in state["last_ad_timestamp"]:
            try:
                # e.g., "now-5" becomes current_time - 5 seconds
                offset = int(state["last_ad_timestamp"].split("-")[1])
                state["last_ad_timestamp"] = int(time.time()) - offset
            except (IndexError, ValueError):
                # Fallback to current time if format is unexpected
                state["last_ad_timestamp"] = int(time.time())

        self.set(key, json.dumps(state))


class MockChromaCollection:
    """
    A mock for the ChromaDB collection object to simulate vector search queries.
    This allows us to test the `orchestrator_node`'s logic for handling retrieved
    documents without needing a live ChromaDB instance or real embeddings.
    """
    def __init__(self):
        # Initialize with an empty result set
        self.mock_results: Dict[str, Any] = {
            "ids": [[]],
            "documents": [[]],
            "metadatas": [[]],
            "distances": [[]]
        }

    def set_query_results(self, ids: List[str], documents: List[str], metadatas: List[Dict]):
        """
        Configures the results that the next call to `query` will return.
        This is called by test functions to set up specific retrieval scenarios.
        """
        self.mock_results = {
            "ids": [ids],
            "documents": [documents],
            "metadatas": [metadatas],
            "distances": [[0.1] * len(ids)] # Dummy distances are sufficient for our tests
        }

    def query(self, query_texts: List[str], n_results: int, where: Dict) -> Dict[str, Any]:
        """
        Mocks the actual query method. It simply returns the pre-configured
        results, ignoring the actual query parameters.
        """
        return self.mock_results


class MockLLM:
    """
    A flexible and powerful mock for the LangChain ChatOpenAI model. This is the
    most critical mock in our suite. It allows for deterministic testing of our
    AI agent nodes by returning pre-defined responses based on keywords found
    in the prompt.
    """
    def __init__(self, response_map: Dict[str, Any]):
        self.response_map = response_map
        self.ainvoke = AsyncMock(side_effect=self._get_response)
        self.invoke = MagicMock(side_effect=self._get_response)

    def _get_response(self, messages: Any, *args, **kwargs) -> Any:
        """The core response logic for both sync and async calls."""
        prompt_content = self._get_prompt_content(messages)

        for key, response in self.response_map.items():
            if key in prompt_content:
                # If the mapped response is NOT a string (e.g., a Pydantic object),
                # return it directly. This correctly simulates the behavior of
                # a chain that has already parsed the output.
                if not isinstance(response, str):
                    return response

                # Otherwise, for regular string generation, wrap in a mock message object.
                mock_response_object = MagicMock()
                mock_response_object.content = response
                return mock_response_object

        raise ValueError(f"MockLLM received an unmapped prompt. Content starts with: {prompt_content[:200]}")

    def _get_prompt_content(self, messages: Any) -> str:
        """Helper to extract text content from various message formats."""
        if isinstance(messages, str):
            return messages
        if isinstance(messages, list):
            full_text = []
            for msg in messages:
                if hasattr(msg, 'content'): # LangChain Message object
                    full_text.append(msg.content)
                elif isinstance(msg, tuple) and len(msg) == 2: # (role, content) tuple
                    full_text.append(str(msg[1]))
            return "\n".join(full_text)
        raise TypeError(f"Unsupported message format for MockLLM: {type(messages)}")

    def with_structured_output(self, *args, **kwargs):
        """Mocks the `with_structured_output` chain method by returning itself."""
        return self


----- FILE: advertis_service/evaluation/test_workflow.py -----
"""
test_workflow.py

This file contains integration tests for the complete `GamingAgent` LangGraph
workflow. These tests are critical for verifying that the conditional edges and
routing logic of the state machine work as expected. We test the main paths:
a full successful injection, a skip at the decision gate, and a skip at the
orchestrator, ensuring the agent follows the correct sequence of nodes for each
scenario.
"""
import pytest
import json
from app.services.verticals.gaming.agent import GamingAgent
from evaluation.test_utils import MockLLM, MockChromaCollection

# --- Helper function to retrieve a test case ---

def get_test_case(full_test_dataset, case_id: str):
    """A simple helper to find and return a specific test case by its ID."""
    for case in full_test_dataset:
        if case['id'] == case_id:
            return case
    raise ValueError(f"Test case with id '{case_id}' not found in dataset.")

# --- Test Cases for Different End-to-End Workflow Scenarios ---

@pytest.mark.asyncio
async def test_workflow_follows_full_injection_path_correctly(full_test_dataset, mocker):
    """
    GIVEN: A test case that should result in a successful ad injection.
    WHEN: The full agent workflow is run via `agent.run()`.
    THEN: The final result should have status="inject" and a valid response text.
    """
    # Arrange
    case = get_test_case(full_test_dataset, "inject_normal_1")
    history = case['history']
    
    # 1. Create and inject the mock dependency
    mock_collection = MockChromaCollection()
    mock_collection.set_query_results(
        ids=['jack-daniels'], documents=['A bottle of whiskey'], metadatas=[{"name": "Jack Daniel's"}]
    )
    agent_for_workflow = GamingAgent(chroma_collection=mock_collection)

    # 2. Mock ALL LLM calls required for this successful path
    decision_gate_response = {"opportunity": True, "reasoning": "Good opportunity."}
    orchestrator_response = {
        "decision": "inject", "product_id": "jack-daniels",
        "creative_brief": {"example_narration": "A bottle of Jack Daniel's sits on the bar."}
    }
    host_llm_response = "You see a dark bar. A bottle of Jack Daniel's sits on the bar. What's your move?"

    mock_llm = MockLLM({
        "Brand Safety Analyst": decision_gate_response,
        "AI Creative Director": json.dumps(orchestrator_response),
        "Narrative Execution Engine": host_llm_response
    })
    mocker.patch('langchain_openai.ChatOpenAI', return_value=mock_llm)

    # Act
    final_result = await agent_for_workflow.run(history=history)

    # Assert
    assert final_result['status'] == 'inject'
    assert "Jack Daniel's" in final_result['response_text']


@pytest.mark.asyncio
async def test_workflow_correctly_skips_at_decision_gate(full_test_dataset, mocker):
    """
    GIVEN: A test case that should be skipped by the decision gate (e.g., brand unsafe).
    WHEN: The full agent workflow is run.
    THEN: The final result should have status="skip".
    """
    # Arrange
    case = get_test_case(full_test_dataset, "skip_decision_gate_2_brand_unsafe")
    history = case['history']
    
    # 1. Inject mock dependency (it won't be used but is required by constructor)
    mock_collection = MockChromaCollection()
    agent_for_workflow = GamingAgent(chroma_collection=mock_collection)

    # 2. Mock only the Decision Gate LLM call to return False
    decision_gate_response = {"opportunity": False, "reasoning": "Brand unsafe content detected."}
    mock_llm = MockLLM({"Brand Safety Analyst": decision_gate_response})
    mocker.patch('langchain_openai.ChatOpenAI', return_value=mock_llm)

    # 3. Spy on subsequent nodes to ensure they are not called
    orchestrator_spy = mocker.spy(agent_for_workflow, 'orchestrator_node')
    host_llm_spy = mocker.spy(agent_for_workflow, 'host_llm_node')

    # Act
    final_result = await agent_for_workflow.run(history=history)

    # Assert
    assert final_result['status'] == 'skip'
    orchestrator_spy.assert_not_called()
    host_llm_spy.assert_not_called()

@pytest.mark.asyncio
async def test_workflow_correctly_skips_at_orchestrator(full_test_dataset, mocker):
    """
    GIVEN: A test case that passes the decision gate but should be skipped by the orchestrator.
    WHEN: The full agent workflow is run.
    THEN: The final result should have status="skip".
    """
    # Arrange
    case = get_test_case(full_test_dataset, "skip_orchestrator_2_no_creative_fit")
    history = case['history']

    # 1. Inject mock dependency
    mock_collection = MockChromaCollection()
    mock_collection.set_query_results(ids=['some_ad'], documents=['...'], metadatas=[{'name': '...'}])
    agent_for_workflow = GamingAgent(chroma_collection=mock_collection)

    # 2. Mock the LLM calls for this specific path
    decision_gate_response = {"opportunity": True, "reasoning": "Context is safe."}
    orchestrator_response = {"decision": "skip"}
    mock_llm = MockLLM({
        "Brand Safety Analyst": decision_gate_response,
        "AI Creative Director": json.dumps(orchestrator_response)
    })
    mocker.patch('langchain_openai.ChatOpenAI', return_value=mock_llm)

    # 3. Spy on the final node to ensure it's not called
    host_llm_spy = mocker.spy(agent_for_workflow, 'host_llm_node')

    # Act
    final_result = await agent_for_workflow.run(history=history)

    # Assert
    assert final_result['status'] == 'skip'
    host_llm_spy.assert_not_called()

----- FILE: advertis_service/evaluation/live_eval/__init__.py -----

----- FILE: advertis_service/evaluation/live_eval/test_live_llm.py -----
"""
test_live_llm.py

A script for evaluating the performance of the GamingAgent's core LLM-driven nodes
against the actual OpenAI API. This is not part of the automated pytest suite and
should be run manually to benchmark prompt performance and model behavior.
"""
import asyncio
import json
import os
import time
import sys
from collections import Counter
from typing import List, Dict, Any
from dotenv import load_dotenv

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../..')))

# --- NEW: Import the factory and agent ---
from app.services.verticals.gaming.agent import GamingAgent
from app.services.vector_store import create_chroma_collection

# --- Configuration ---
load_dotenv()
if not os.getenv("OPENAI_API_KEY"):
    raise ValueError("FATAL: OPENAI_API_KEY environment variable is missing.")

LIVE_EVAL_CASE_IDS = [
    "inject_normal_1",
    "inject_tech_1",
    "skip_safety_gate_1_stuck",
    "skip_decision_gate_1_short_convo",
    "skip_decision_gate_2_brand_unsafe"
]
NUM_RUNS_PER_CASE = 3

# --- Main Evaluation Logic ---

def load_live_eval_cases() -> List[Dict[str, Any]]:
    """Loads only the specified cases for live evaluation from the main dataset."""
    with open("evaluation/data/test_dataset.json", "r") as f:
        full_dataset = json.load(f)
    case_map = {case['id']: case for case in full_dataset}
    return [case_map[case_id] for case_id in LIVE_EVAL_CASE_IDS if case_id in case_map]

async def evaluate_decision_gate_for_case(agent: GamingAgent, case: Dict[str, Any]) -> Dict[str, Any]:
    """
    Runs the decision_gate_node for a single case multiple times and evaluates its output.
    """
    print(f"  - Evaluating Decision Gate for case: {case['id']} ({NUM_RUNS_PER_CASE} runs)...")
    initial_state = {"conversation_history": case['history']}
    
    responses = []
    errors = 0
    
    for i in range(NUM_RUNS_PER_CASE):
        try:
            result_state = await agent.decision_gate_node.ainvoke(initial_state)
            responses.append(result_state['opportunity_assessment'])
        except Exception as e:
            print(f"          ERROR during LLM call: {e}")
            errors += 1

    if not responses:
        return {"case_id": case['id'], "error_rate": 1.0}

    expected_opportunity = case['expected_paths'] != ['pre-flight-fail'] and case['expected_status'] == 'inject'
    correct_decisions = sum(1 for r in responses if r.get('opportunity') == expected_opportunity)
    accuracy = correct_decisions / len(responses)
    
    return {
        "case_id": case['id'],
        "expected_opportunity": expected_opportunity,
        "accuracy": f"{accuracy:.2%}",
        "raw_responses": responses
    }


async def main():
    """Main function to orchestrate the live evaluation."""
    print("--- Starting Live LLM Evaluation ---")
    
    # --- NEW: Create and inject the REAL dependency ---
    print("Connecting to ChromaDB for live evaluation...")
    # NOTE: This requires the chroma_db Docker container to be running.
    # We set the CHROMA_URL to point to localhost as this script runs outside Docker.
    os.environ["CHROMA_URL"] = "http://localhost:8001"
    
    try:
        live_collection = create_chroma_collection()
        agent = GamingAgent(chroma_collection=live_collection)
    except Exception as e:
        print(f"\nFATAL ERROR: Could not connect to ChromaDB for live evaluation.")
        print("Please ensure the Docker containers are running with 'docker-compose up -d'.")
        print(f"Details: {e}")
        return

    cases_to_run = load_live_eval_cases()
    decision_gate_results = []
    
    print(f"\nRunning evaluations for {len(cases_to_run)} test cases...")
    
    for case in cases_to_run:
        gate_result = await evaluate_decision_gate_for_case(agent, case)
        decision_gate_results.append(gate_result)
        time.sleep(1) 

    final_report = {
        "evaluation_timestamp": time.strftime("%Y-%m-%d %H:%M:%S UTC", time.gmtime()),
        "summary": {"total_cases_tested": len(cases_to_run)},
        "detailed_results": decision_gate_results
    }
    
    print("\n--- Live LLM Evaluation Complete ---")
    print(json.dumps(final_report, indent=4))


if __name__ == "__main__":
    asyncio.run(main())

----- FILE: advertis_service/evaluation/data/test_dataset.json -----
[
    {
      "id": "inject_normal_1",
      "description": "This is the canonical 'happy path' test case. The user enters a classic noir setting (a bar), which presents a clear and contextually appropriate opportunity for a beverage or mood-setting ad. All pre-flight checks are expected to pass, the decision gate should see this as a prime opportunity, the orchestrator should easily find relevant ads like whiskey, and the final response should be an injection. This tests the full, successful 'inject' workflow.",
      "history": [
        { "role": "system", "content": "You are a sarcastic and world-weary Game Master running a noir detective story in a cyberpunk city." },
        { "role": "user", "content": "I walk into the dimly lit bar, rain dripping from my trench coat." }
      ],
      "last_message": "I walk into the dimly lit bar, rain dripping from my trench coat.",
      "session_id": "session_inject_1",
      "redis_state": { "total_turns": 2, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["jack-daniels", "coca-cola", "heineken-bottle", "bladerunner-whiskey-glass"],
      "ideal_response_snippet": "bottle of Jack Daniel's",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_normal_2",
      "description": "Tests another common scenario: a need for transportation. The user's intent is explicit ('I need to get out... I look for a vehicle'), making it a strong signal for the vector search. This case verifies that vehicle-type ads are correctly retrieved and injected in an action-oriented context.",
      "history": [
        { "role": "system", "content": "You are a sarcastic and world-weary Game Master running a noir detective story in a cyberpunk city." },
        { "role": "user", "content": "The deal went south. I need to get out of this sector, fast. I look for a vehicle." }
      ],
      "last_message": "The deal went south. I need to get out of this sector, fast. I look for a vehicle.",
      "session_id": "session_inject_2",
      "redis_state": { "total_turns": 5, "ads_shown": 1, "last_ad_turn": 1, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["ford-mustang", "honda-civic", "tesla-cybertruck", "uber-ride"],
      "ideal_response_snippet": "Ford Mustang",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_tech_1",
      "description": "This case targets technology and equipment ads within a cyberpunk setting. The user is hacking, a perfect moment for mentioning keyboards, monitors, or fictional cyberdecks. It tests the system's ability to match specific actions with relevant equipment categories.",
      "history": [
        { "role": "system", "content": "You are a sarcastic and world-weary Game Master running a noir detective story in a cyberpunk city." },
        { "role": "user", "content": "I jack into the corporate mainframe. My fingers fly across the console as I try to bypass the ICE." }
      ],
      "last_message": "I jack into the corporate mainframe. My fingers fly across the console as I try to bypass the ICE.",
      "session_id": "session_inject_3",
      "redis_state": { "total_turns": 4, "ads_shown": 1, "last_ad_turn": 0, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["razer-keyboard", "alienware-monitor", "arasaka-cyberdeck"],
      "ideal_response_snippet": "Razer keyboard",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_fantasy_1",
      "description": "This case is critical for testing vertical-specific, lore-based ads. The setting is fantasy, not cyberpunk. The user is injured, providing an unambiguous opportunity for a 'health potion' ad. This validates that the system can handle different genres and correctly retrieve fictional, in-world items.",
      "history": [
        { "role": "system", "content": "You are a wise old wizard guiding a hero through a dark forest." },
        { "role": "user", "content": "The goblin's arrow grazed my arm. I need to patch myself up before I bleed out." }
      ],
      "last_message": "The goblin's arrow grazed my arm. I need to patch myself up before I bleed out.",
      "session_id": "session_inject_4",
      "redis_state": { "total_turns": 8, "ads_shown": 2, "last_ad_turn": 4, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["eldorian-health-potion"],
      "ideal_response_snippet": "Eldorian Health Potion",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_safety_gate_1_stuck",
      "description": "This is a core test for the pre-flight safety gate. The user explicitly uses the keyword 'stuck', which is in the HIGH_CONSEQUENCE_KEYWORDS list. The system must reject this request at the pre-flight stage, and the agent workflow (decision_gate, etc.) should never be invoked. The expected path is 'pre-flight-fail'.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I'm completely stuck. What am I supposed to do in this room?" }
      ],
      "last_message": "I'm completely stuck. What am I supposed to do in this room?",
      "session_id": "session_skip_safety_1",
      "redis_state": { "total_turns": 3, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "skip_safety_gate_2_help",
      "description": "Another crucial safety gate test. The keyword is 'help'. The expected outcome is identical to the 'stuck' case: an immediate rejection at the pre-flight check before the main agent is called.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "Can you help me? I don't understand the puzzle." }
      ],
      "last_message": "Can you help me? I don't understand the puzzle.",
      "session_id": "session_skip_safety_2",
      "redis_state": { "total_turns": 5, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "skip_safety_gate_3_confused",
      "description": "Tests the safety gate keyword 'confused'. This ensures that various forms of player frustration are correctly captured and handled by skipping ad opportunities, thereby protecting the user experience during critical moments.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I'm confused about what happened to the informant." }
      ],
      "last_message": "I'm confused about what happened to the informant.",
      "session_id": "session_skip_safety_3",
      "redis_state": { "total_turns": 2, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "skip_frequency_gate_1_ad_limit",
      "description": "This case tests the absolute session ad limit. The `redis_state` is pre-configured to have `ads_shown` equal to `MAX_ADS_PER_SESSION`. The frequency gate must reject this request, preventing ad fatigue for the user within a single session.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I check my gear one last time." }
      ],
      "last_message": "I check my gear one last time.",
      "session_id": "session_skip_freq_1",
      "redis_state": { "total_turns": 50, "ads_shown": 15, "last_ad_turn": 45, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "skip_frequency_gate_2_turn_limit",
      "description": "Tests the turn-based frequency cap. The `redis_state` shows an ad was displayed only one turn ago (`last_ad_turn`: 9, `total_turns`: 10), which is less than `MIN_TURNS_BETWEEN_ADS`. The gate must reject this to ensure ads are not shown back-to-back.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I open the next door." }
      ],
      "last_message": "I open the next door.",
      "session_id": "session_skip_freq_2",
      "redis_state": { "total_turns": 10, "ads_shown": 3, "last_ad_turn": 9, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "skip_frequency_gate_3_cooldown",
      "description": "Tests the time-based cooldown period. The `redis_state` is dynamically configured in the test to show an ad was displayed just 5 seconds ago, which is less than `COOLDOWN_SECONDS`. This gate must reject the request to prevent rapid-fire ads even if the turn count is met.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "And then what happens?" }
      ],
      "last_message": "And then what happens?",
      "session_id": "session_skip_freq_3",
      "redis_state": { "total_turns": 15, "ads_shown": 4, "last_ad_turn": 11, "last_ad_timestamp": "now-5" },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "pass_frequency_gate_1_new_session",
      "description": "This case validates the default-allow behavior for a brand new session. The `redis_state` is `null`, simulating a session ID that Redis has never seen. The frequency gate should pass, allowing the request to proceed to the main agent workflow.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "Let's begin. I'm in a tavern." }
      ],
      "last_message": "Let's begin. I'm in a tavern.",
      "session_id": "session_pass_freq_1",
      "redis_state": null,
      "expected_status": "inject",
      "expected_ad_ids": ["starlight-cascade-ale", "jack-daniels"],
      "ideal_response_snippet": "Starlight Cascade Ale",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_decision_gate_1_short_convo",
      "description": "This tests the agent-level decision making, specifically the 'Initial User Interaction' red flag. The user's message is just 'hi'. The pre-flight checks should pass, but the `decision_gate_node` must recognize that this is not a meaningful moment for an ad and decide to skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "hi" }
      ],
      "last_message": "hi",
      "session_id": "session_skip_decision_1",
      "redis_state": { "total_turns": 1, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "skip_decision_gate_2_brand_unsafe",
      "description": "Tests the 'Brand-Unsafe Content' red flag within the `decision_gate_node`. The context is a 'gruesome crime scene'. While the pre-flight safety gate might miss this (as it's keyword-based), the more sophisticated LLM-based decision gate must flag this context as inappropriate for a commercial mention.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I examine the gruesome crime scene, noting the blood spatter on the walls." }
      ],
      "last_message": "I examine the gruesome crime scene, noting the blood spatter on the walls.",
      "session_id": "session_skip_decision_2",
      "redis_state": { "total_turns": 6, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "skip_orchestrator_1_no_relevant_ads",
      "description": "This case tests the scenario where the orchestrator must skip because vector retrieval yields no good candidates. The user's query is highly abstract and philosophical, making it unlikely to match any product descriptions in ChromaDB. The test will mock an empty return from Chroma, forcing the orchestrator to skip without ever calling its LLM.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I ponder the philosophical implications of my existence as a replicant." }
      ],
      "last_message": "I ponder the philosophical implications of my existence as a replicant.",
      "session_id": "session_skip_orch_1",
      "redis_state": { "total_turns": 7, "ads_shown": 2, "last_ad_turn": 3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "orchestrator", "skip_node"]
    },
    {
      "id": "inject_post_apocalyptic_1",
      "description": "Validates ad injection in a post-apocalyptic setting. Scavenging in a supermarket is a perfect setup for finding old, branded food items. This tests the retrieval of both real-world (Coca-Cola) and lore-based (Nuka-Cola) ads in a survival context.",
      "history": [
        { "role": "system", "content": "You are a survivor in a desolate wasteland." },
        { "role": "user", "content": "I scavenge through the ruins of an old supermarket. Is there anything edible?" }
      ],
      "last_message": "I scavenge through the ruins of an old supermarket. Is there anything edible?",
      "session_id": "session_inject_pa_1",
      "redis_state": { "total_turns": 3, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["nuka-cola", "coca-cola", "doritos", "slocums-joe-coffee"],
      "ideal_response_snippet": "Nuka-Cola",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_multi_turn_1",
      "description": "A complex case testing multi-turn context awareness. An ad was already shown on turn 2 (`Ford Mustang`). The conversation continues for several turns. A new ad opportunity arises on turn 6. The `redis_state` shows enough turns have passed, so the frequency gate should pass, and a new ad should be injected. This validates the entire stateful system.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I drive my Ford Mustang down the neon-lit highway." },
        { "role": "assistant", "content": "The engine of the Ford Mustang purrs as you weave through traffic. A billboard for Synth-Soul flashes by. Where are you heading?" },
        { "role": "user", "content": "To the night market. I need to buy some new gear." },
        { "role": "assistant", "content": "The market is a chaotic symphony of sights and sounds. Vendors hawk everything from illegal cybernetics to fresh noodles. What are you looking for specifically?" },
        { "role": "user", "content": "Something to protect me from the rain." }
      ],
      "last_message": "Something to protect me from the rain.",
      "session_id": "session_inject_multi_1",
      "redis_state": { "total_turns": 6, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["the-north-face-jacket", "dr-martens-boots"],
      "ideal_response_snippet": "North Face jacket",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_orchestrator_2_no_creative_fit",
      "description": "This tests the creative judgment of the `orchestrator_node`'s LLM. Even if vector search retrieves potential ads, the LLM is instructed to skip if none are a good creative fit. A 'spell of pure light' is a poor match for any commercial product, so the orchestrator's LLM should decide to skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I cast a complex spell of pure light to banish the shadows." }
      ],
      "last_message": "I cast a complex spell of pure light to banish the shadows.",
      "session_id": "session_skip_orch_2",
      "redis_state": { "total_turns": 9, "ads_shown": 2, "last_ad_turn": 5, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "orchestrator", "skip_node"]
    },
    {
      "id": "inject_equipment_1",
      "description": "A straightforward case where the user's action of 'packing a bag' directly implies a need for tools and equipment, testing the retrieval of ads from the 'equipment' type category.",
      "history": [
        { "role": "system", "content": "You are a grizzled operative briefing a new recruit." },
        { "role": "user", "content": "Okay, I'm ready. I pack my bag with the essentials for the infiltration." }
      ],
      "last_message": "Okay, I'm ready. I pack my bag with the essentials for the infiltration.",
      "session_id": "session_inject_equip_1",
      "redis_state": { "total_turns": 4, "ads_shown": 1, "last_ad_turn": 0, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["leatherman-multitool", "zippo-lighter", "maglite-flashlight", "3m-duct-tape"],
      "ideal_response_snippet": "Leatherman multitool",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_apparel_1",
      "description": "This case targets the 'apparel' ad category. The user is explicitly thinking about what to wear, making it a very strong signal for clothing and accessory brands.",
      "history": [
        { "role": "system", "content": "You are a fashion-conscious AI assistant." },
        { "role": "user", "content": "I need a tough but casual look for tonight's meeting with the informant." }
      ],
      "last_message": "I need a tough but casual look for tonight's meeting with the informant.",
      "session_id": "session_inject_apparel_1",
      "redis_state": { "total_turns": 2, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["levis-jeans", "dr-martens-boots", "carhartt-beanie", "ray-ban-sunglasses"],
      "ideal_response_snippet": "Levi's 501 jeans",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_action_type_1",
      "description": "This case is designed to test the 'action' ad type. These are not physical products but brand actions like 'Google Search' or 'Uber Ride'. The user's need for 'information' should trigger the retrieval of these service-based ads.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I don't know where to find him. I need to get some information on his last known location." }
      ],
      "last_message": "I don't know where to find him. I need to get some information on his last known location.",
      "session_id": "session_inject_action_1",
      "redis_state": { "total_turns": 5, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["google-search", "uber-ride"],
      "ideal_response_snippet": "Google search",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_lore_western_1",
      "description": "Tests the system's ability to adapt to a 'western' genre. The context of a stranger riding into town should trigger retrieval of iconic western brands and items like Stetson and Colt.",
      "history": [
        { "role": "system", "content": "You are a stoic Sheriff in the Old West." },
        { "role": "user", "content": "The stranger rides into town on a pale horse, dust coating his hat." }
      ],
      "last_message": "The stranger rides into town on a pale horse, dust coating his hat.",
      "session_id": "session_inject_western_1",
      "redis_state": { "total_turns": 1, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["stetson-hat", "colt-peacemaker", "levis-jeans"],
      "ideal_response_snippet": "Stetson hat",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_food_1",
      "description": "A classic 'diner setting' test. The explicit mention of a diner and coffee should make it very easy for the retrieval system to find relevant food and drink ads.",
      "history": [
        { "role": "system", "content": "You are a film noir detective." },
        { "role": "user", "content": "I slide into a booth at the 24-hour diner and wave the waitress over. I need coffee." }
      ],
      "last_message": "I slide into a booth at the 24-hour diner and wave the waitress over. I need coffee.",
      "session_id": "session_inject_food_1",
      "redis_state": { "total_turns": 4, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["starbucks-coffee", "heinz-ketchup", "mcdonalds-fries", "coca-cola"],
      "ideal_response_snippet": "Starbucks Pike Place",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_user_negative_sentiment_1",
      "description": "An edge case for the `decision_gate_node`. The user's message doesn't contain a specific keyword like 'stuck' or 'help', but the overall sentiment is highly negative. The LLM in the decision gate should be smart enough to interpret this negative sentiment as a 'brand-unsafe' moment and decide to skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "This is pointless. My character is failing at everything and I'm not having fun." }
      ],
      "last_message": "This is pointless. My character is failing at everything and I'm not having fun.",
      "session_id": "session_skip_negative_1",
      "redis_state": { "total_turns": 12, "ads_shown": 3, "last_ad_turn": 8, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "inject_car_chase_1",
      "description": "A high-octane action scene. This context is suitable for brands associated with energy, speed, and power, like performance cars or energy drinks. Tests the 'action' tone matching.",
      "history": [
        { "role": "system", "content": "You are narrating an action movie." },
        { "role": "user", "content": "I slam the gas pedal, weaving through oncoming traffic as explosions rock the street behind me." }
      ],
      "last_message": "I slam the gas pedal, weaving through oncoming traffic as explosions rock the street behind me.",
      "session_id": "session_inject_chase_1",
      "redis_state": { "total_turns": 7, "ads_shown": 1, "last_ad_turn": 3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["ford-mustang", "red-bull", "jeep-wrangler"],
      "ideal_response_snippet": "Red Bull",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_investigation_1",
      "description": "This test case focuses on a slower, more contemplative investigation scene. It's an opportunity for more subtle, environmental placements like pens, notepads, or a flashlight, testing the retrieval of 'mundane' but contextually relevant items.",
      "history": [
        { "role": "system", "content": "You are a detective in a noir story." },
        { "role": "user", "content": "I search the victim's messy office for any clues. I need to write down my findings." }
      ],
      "last_message": "I search the victim's messy office for any clues. I need to write down my findings.",
      "session_id": "session_inject_investigate_1",
      "redis_state": { "total_turns": 6, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["bic-pen", "post-it-note", "maglite-flashlight", "amazon-box"],
      "ideal_response_snippet": "Bic pen",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_home_setting_1",
      "description": "Tests ad placement in a domestic, 'home' setting. This opens up different categories of ads, like furniture or packages, that might not fit in an action scene. It validates the system's versatility across different environments.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I'm back at my apartment. I need to organize the evidence I've collected on my bookshelf." }
      ],
      "last_message": "I'm back at my apartment. I need to organize the evidence I've collected on my bookshelf.",
      "session_id": "session_inject_home_1",
      "redis_state": { "total_turns": 8, "ads_shown": 2, "last_ad_turn": 4, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["ikea-shelf", "amazon-box", "fedex-envelope"],
      "ideal_response_snippet": "IKEA bookshelf",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_safety_gate_4_rule",
      "description": "Tests the safety gate's handling of meta-questions about game rules. When a player asks for a 'rule', it's a high-consequence moment where an ad would be disruptive. This must be caught by the pre-flight check.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "What's the rule for stealth checks again?" }
      ],
      "last_message": "What's the rule for stealth checks again?",
      "session_id": "session_skip_safety_4",
      "redis_state": { "total_turns": 4, "ads_shown": 1, "last_ad_turn": 1, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "inject_space_opera_1",
      "description": "This case tests the 'space-opera' genre. The context of a starship encounter should trigger the retrieval of fictional sci-fi corporate brands like 'Weyland-Yutani' or 'Hyperion', demonstrating the system's capacity for deep-lore integration.",
      "history": [
        { "role": "system", "content": "You are the captain of a starship." },
        { "role": "user", "content": "The alien vessel is hailing us. On screen. Let's see what they want." }
      ],
      "last_message": "The alien vessel is hailing us. On screen. Let's see what they want.",
      "session_id": "session_inject_space_1",
      "redis_state": { "total_turns": 10, "ads_shown": 2, "last_ad_turn": 6, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["hyperion-starship", "weyland-yutani-logo", "arclight-industries-plasma-rifle"],
      "ideal_response_snippet": "Weyland-Yutani",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_decision_gate_3_OOC",
      "description": "This tests the decision gate's ability to recognize out-of-character (OOC) communication. When a user is talking about the game rather than in it, it's not a narrative moment suitable for an ad. The gate's LLM should identify this and skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "(OOC: I love this story so far! The writing is great.)" }
      ],
      "last_message": "(OOC: I love this story so far! The writing is great.)",
      "session_id": "session_skip_ooc_1",
      "redis_state": { "total_turns": 11, "ads_shown": 3, "last_ad_turn": 7, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "inject_music_1",
      "description": "The user explicitly mentions music, which should be a strong signal for retrieving brands related to audio, like Spotify, Sony headphones, or even musical instruments like Gibson.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I put on some moody jazz to think. The saxophone solo fills the quiet office." }
      ],
      "last_message": "I put on some moody jazz to think. The saxophone solo fills the quiet office.",
      "session_id": "session_inject_music_1",
      "redis_state": { "total_turns": 5, "ads_shown": 1, "last_ad_turn": 1, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["spotify-playlist", "sony-headphones", "gibson-guitar"],
      "ideal_response_snippet": "Spotify playlist",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_luxury_1",
      "description": "This case targets the 'luxurious' tone. The setting of a corporate gala provides a perfect backdrop for high-end brands like Rolex or Gucci, testing the system's ability to match the tone of the scene with appropriately toned products.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "The gala is full of corporate elites. The woman across the room is watching me. What is she wearing?" }
      ],
      "last_message": "The gala is full of corporate elites. The woman across the room is watching me. What is she wearing?",
      "session_id": "session_inject_luxury_1",
      "redis_state": { "total_turns": 9, "ads_shown": 2, "last_ad_turn": 5, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["rolex-watch", "gucci-handbag"],
      "ideal_response_snippet": "Rolex watch",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_direct_question_to_gm_1",
      "description": "Tests another meta-question scenario for the decision gate. The user is asking for game mechanics ('hit points'), not participating in the narrative. This is not an appropriate moment for a product placement, and the decision gate must skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "How many hit points does the guard have?" }
      ],
      "last_message": "How many hit points does the guard have?",
      "session_id": "session_skip_direct_q_1",
      "redis_state": { "total_turns": 6, "ads_shown": 1, "last_ad_turn": 3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "inject_corporate_setting_1",
      "description": "A classic corporate office setting should trigger retrieval of related products like workhorse laptops (Dell), office supplies (Post-it, Bic), or the quintessential office coffee.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I sit at my cubicle, the fluorescent lights humming overhead. The report is due by five." }
      ],
      "last_message": "I sit at my cubicle, the fluorescent lights humming overhead. The report is due by five.",
      "session_id": "session_inject_corp_1",
      "redis_state": { "total_turns": 3, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["dell-laptop", "post-it-note", "starbucks-coffee", "bic-pen"],
      "ideal_response_snippet": "Dell Latitude laptop",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "pass_frequency_gate_2_turn_limit_met",
      "description": "This case specifically tests the boundary condition of the turn-based frequency gate. Exactly `MIN_TURNS_BETWEEN_ADS` (3) turns have passed since the last ad (`total_turns`: 10, `last_ad_turn`: 7). The gate should correctly identify this as a valid opportunity and pass the request.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I follow the trail into the woods." }
      ],
      "last_message": "I follow the trail into the woods.",
      "session_id": "session_pass_freq_2",
      "redis_state": { "total_turns": 10, "ads_shown": 2, "last_ad_turn": 7, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["the-north-face-jacket", "leatherman-multitool"],
      "ideal_response_snippet": "The North Face jacket",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_sports_context_1",
      "description": "Tests a sports or athletic context. A user heading to the gym is a strong signal for athletic apparel and related brands. This validates the matching of 'athletic' or 'high-energy' tones.",
      "history": [
        { "role": "system", "content": "You are a personal trainer AI." },
        { "role": "user", "content": "Okay, workout loaded. I'm heading to the gym to hit the weights." }
      ],
      "last_message": "Okay, workout loaded. I'm heading to the gym to hit the weights.",
      "session_id": "session_inject_sports_1",
      "redis_state": { "total_turns": 2, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["under-armour-shirt", "nike-sneakers", "red-bull"],
      "ideal_response_snippet": "Under Armour",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_nostalgic_1",
      "description": "This case tests a nostalgic context. The user is in their childhood room, which is an opportunity to place brands associated with nostalgia or childhood, such as Lego or Polaroid.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I enter my old childhood bedroom. It's dusty, but mostly unchanged. I see my old toys on the floor." }
      ],
      "last_message": "I enter my old childhood bedroom. It's dusty, but mostly unchanged. I see my old toys on the floor.",
      "session_id": "session_inject_nostalgia_1",
      "redis_state": { "total_turns": 5, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["lego-bricks", "polaroid-photo"],
      "ideal_response_snippet": "Lego bricks",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_conspiracy_1",
      "description": "A test case for a very specific 'conspiracy' genre, designed to trigger the retrieval of the 'Abstergo Industries' lore brand from the ad inventory, which is tagged with this genre.",
      "history": [
        { "role": "system", "content": "You are a conspiracy theorist." },
        { "role": "user", "content": "It all connects back to the Templars. They're still pulling the strings from the shadows, using their front companies." }
      ],
      "last_message": "It all connects back to the Templars. They're still pulling the strings from the shadows, using their front companies.",
      "session_id": "session_inject_conspiracy_1",
      "redis_state": { "total_turns": 7, "ads_shown": 1, "last_ad_turn": 3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["abstergo-tablet"],
      "ideal_response_snippet": "Abstergo Industries",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_orchestrator_3_bad_retrieval",
      "description": "This case ensures the system gracefully handles poor retrieval results from ChromaDB. The query 'I do a thing' is intentionally vague. The test will mock Chroma returning no results, forcing the orchestrator to skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I do a thing." }
      ],
      "last_message": "I do a thing.",
      "session_id": "session_skip_orch_3",
      "redis_state": { "total_turns": 3, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "orchestrator", "skip_node"]
    },
    {
      "id": "inject_horror_1",
      "description": "This case tests ad injection within a 'horror' context. A mundane item like a Sharpie marker can become a creepy element in a horror narrative, showing the system's ability to adapt brand mentions to the prevailing tone.",
      "history": [
        { "role": "system", "content": "You are narrating a horror story." },
        { "role": "user", "content": "The only light in the abandoned asylum comes from my flashlight. A message is scrawled on the wall." }
      ],
      "last_message": "The only light in the abandoned asylum comes from my flashlight. A message is scrawled on the wall.",
      "session_id": "session_inject_horror_1",
      "redis_state": { "total_turns": 4, "ads_shown": 1, "last_ad_turn": 1, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["sharpie-marker", "maglite-flashlight"],
      "ideal_response_snippet": "Sharpie marker",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_empty_message_1",
      "description": "An edge case test. The user submits an empty string. The pre-flight safety gate should pass this, but the `decision_gate_node` should recognize there is no meaningful content to analyze and decide to skip the opportunity.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "" }
      ],
      "last_message": "",
      "session_id": "session_skip_empty_1",
      "redis_state": { "total_turns": 2, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "inject_comedy_1",
      "description": "Tests a comedic context. The situation is absurd (using duct tape as a rope), providing a good opportunity for a brand that fits a 'comedic' or 'practical' tone, like 3M duct tape.",
      "history": [
        { "role": "system", "content": "You are a GM for a lighthearted adventure." },
        { "role": "user", "content": "I try to heroically swing across the chasm on a rope, but it's just a roll of tape I found." }
      ],
      "last_message": "I try to heroically swing across the chasm on a rope, but it's just a roll of tape I found.",
      "session_id": "session_inject_comedy_1",
      "redis_state": { "total_turns": 6, "ads_shown": 1, "last_ad_turn": 3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["3m-duct-tape"],
      "ideal_response_snippet": "3M duct tape",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_cozy_fantasy_1",
      "description": "This case targets the 'cozy-fantasy' sub-genre. The context is calm and relaxing (sitting by a fire), making it suitable for lore items associated with comfort, like special pipe-tobacco or ale.",
      "history": [
        { "role": "system", "content": "You are a halfling innkeeper." },
        { "role": "user", "content": "After a long day's journey, I settle into a comfortable chair by the fire and light my pipe." }
      ],
      "last_message": "After a long day's journey, I settle into a comfortable chair by the fire and light my pipe.",
      "session_id": "session_inject_cozy_1",
      "redis_state": { "total_turns": 4, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["kingswood-pipe-tobacco", "starlight-cascade-ale"],
      "ideal_response_snippet": "Kingswood pipe-tobacco",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_military_1",
      "description": "A military setting test. The user is in an armory, which should be a very strong signal for retrieving weapon and military-tech lore brands like 'Militech' or 'Arclight Industries'.",
      "history": [
        { "role": "system", "content": "You are a drill sergeant in a futuristic army." },
        { "role": "user", "content": "I pick up my standard-issue sidearm from the armory rack." }
      ],
      "last_message": "I pick up my standard-issue sidearm from the armory rack.",
      "session_id": "session_inject_military_1",
      "redis_state": { "total_turns": 2, "ads_shown": 0, "last_ad_turn": -3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["militech-pistol", "arclight-industries-plasma-rifle"],
      "ideal_response_snippet": "Militech 'Avenger' pistol",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_direct_command_1",
      "description": "This tests the decision gate's handling of low-effort, non-narrative commands. A command like 'go north' lacks the descriptive richness needed for a good ad placement, so the gate should decide to skip.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "go north" }
      ],
      "last_message": "go north",
      "session_id": "session_skip_command_1",
      "redis_state": { "total_turns": 8, "ads_shown": 2, "last_ad_turn": 4, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["decision_gate", "skip_node"]
    },
    {
      "id": "inject_mundane_1",
      "description": "Tests a very mundane, everyday situation. Waiting for an elevator is a moment where a character might be listening to music or thinking about a show, providing an opportunity for related service brands.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I wait for the elevator. The music is terrible." }
      ],
      "last_message": "I wait for the elevator. The music is terrible.",
      "session_id": "session_inject_mundane_1",
      "redis_state": { "total_turns": 4, "ads_shown": 1, "last_ad_turn": 1, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["spotify-playlist", "netflix-show"],
      "ideal_response_snippet": "Spotify playlist",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_weather_1",
      "description": "The user's description of the weather ('cold wind') is a direct prompt for placing ads related to protective apparel, like jackets or hats.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "A cold wind whips through the alley, forcing me to pull my collar up." }
      ],
      "last_message": "A cold wind whips through the alley, forcing me to pull my collar up.",
      "session_id": "session_inject_weather_1",
      "redis_state": { "total_turns": 5, "ads_shown": 1, "last_ad_turn": 2, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["the-north-face-jacket", "carhartt-beanie", "dr-martens-boots"],
      "ideal_response_snippet": "Carhartt beanie",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "skip_safety_gate_5_hint",
      "description": "Final test for the safety gate keywords. A request for a 'hint' indicates the player needs help, making it an inappropriate time for an ad. This must be rejected by the pre-flight check.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "Could I get a hint?" }
      ],
      "last_message": "Could I get a hint?",
      "session_id": "session_skip_safety_5",
      "redis_state": { "total_turns": 7, "ads_shown": 2, "last_ad_turn": 4, "last_ad_timestamp": 0 },
      "expected_status": "skip",
      "expected_ad_ids": [],
      "ideal_response_snippet": null,
      "expected_paths": ["pre-flight-fail"]
    },
    {
      "id": "inject_generic_equipment_1",
      "description": "Tests the system's ability to replace a generic term ('multi-tool') with a specific brand ('Leatherman'). The vector search should match the generic description to the specific product in the ad inventory.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I use my multi-tool to jimmy the lock on the maintenance panel." }
      ],
      "last_message": "I use my multi-tool to jimmy the lock on the maintenance panel.",
      "session_id": "session_inject_generic_1",
      "redis_state": { "total_turns": 6, "ads_shown": 1, "last_ad_turn": 3, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["leatherman-multitool"],
      "ideal_response_snippet": "Leatherman",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_travel_1",
      "description": "The context of air travel is a clear opportunity to place ads for airplane manufacturers or travel accessories like noise-cancelling headphones.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I board the massive passenger plane, finding my seat for the long flight to Neo-Kyoto." }
      ],
      "last_message": "I board the massive passenger plane, finding my seat for the long flight to Neo-Kyoto.",
      "session_id": "session_inject_travel_1",
      "redis_state": { "total_turns": 9, "ads_shown": 2, "last_ad_turn": 5, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["boeing-747", "sony-headphones"],
      "ideal_response_snippet": "Boeing 747",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    },
    {
      "id": "inject_final_boss_1",
      "description": "This case tests whether a subtle environmental ad can be placed even during a high-stakes 'final boss' encounter. The focus is on the enemy's equipment, providing an opportunity to mention the fictional corporation that manufactured their cybernetics.",
      "history": [
        { "role": "system", "content": "You are a Game Master." },
        { "role": "user", "content": "I face the cyborg assassin on the rain-slicked rooftop. His chrome arm gleams." }
      ],
      "last_message": "I face the cyborg assassin on the rain-slicked rooftop. His chrome arm gleams.",
      "session_id": "session_inject_boss_1",
      "redis_state": { "total_turns": 20, "ads_shown": 4, "last_ad_turn": 15, "last_ad_timestamp": 0 },
      "expected_status": "inject",
      "expected_ad_ids": ["omnicorp-cybernetics", "militech-pistol"],
      "ideal_response_snippet": "Omni-Corp",
      "expected_paths": ["decision_gate", "orchestrator", "host_llm"]
    }
  ]

